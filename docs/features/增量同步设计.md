# 增量同步设计

## 📋 文档说明

本文档详细描述 DataTrace 系统的增量同步机制，支持多种同步模式和增量策略。

**文档版本**: v2.0  
**最后更新**: 2026-02-27  
**技术栈**: Go + Gin + GORM  
**实现状态**: 设计阶段

---

## 🎯 设计目标

### 核心需求

1. **避免重复同步**: 已同步的数据不再重复同步
2. **灵活配置**: 用户可以选择同步模式（全量/增量/跳过已完成）
3. **多种策略**: 支持基于时间戳、自增ID、版本号的增量同步
4. **断点续传**: 记录上次同步位置，支持中断后继续
5. **性能优化**: 减少数据传输量，提高同步效率

---

## 🏗️ 同步模式设计

### 三种同步模式

**1. Full Mode (全量同步)**
- 每次都同步所有数据
- 适用场景: 数据量小、需要完全一致
- 优点: 简单可靠
- 缺点: 数据量大时效率低

**2. Skip Completed Mode (跳过已完成)**
- 任务单元级别，已完成的单元不再执行
- 适用场景: 多表同步，部分表已完成
- 优点: 支持断点续传
- 缺点: 单个表内的数据仍是全量
- 状态: ✅ 已实现

**3. Incremental Mode (增量同步)**
- 记录级别，只同步新增/修改的数据
- 适用场景: 数据量大、频繁同步
- 优点: 效率高、节省资源
- 缺点: 需要数据源支持增量字段
- 状态: 🚧 待实现

---

## 📊 增量同步策略

### 策略 1: 基于时间戳 (Timestamp)

**原理**: 使用时间戳字段（如 `updated_at`）过滤数据

**SQL 示例**:
```sql
-- 首次同步
SELECT * FROM users WHERE updated_at >= '1970-01-01 00:00:00';

-- 增量同步
SELECT * FROM users WHERE updated_at > '2026-02-27 10:00:00';
```

**适用场景**:
- 表有 `created_at` 或 `updated_at` 字段
- 数据有明确的修改时间
- 时间戳字段有索引

### 策略 2: 基于自增 ID (Auto Increment)

**原理**: 使用自增主键过滤数据

**SQL 示例**:
```sql
-- 首次同步
SELECT * FROM users WHERE id >= 0;

-- 增量同步
SELECT * FROM users WHERE id > 12345;
```

**适用场景**:
- 表有自增主键
- 只需要同步新增数据（不关心修改）
- 数据不会被删除

### 策略 3: 基于版本号 (Version)

**原理**: 使用版本号字段过滤数据

**SQL 示例**:
```sql
-- 首次同步
SELECT * FROM users WHERE version >= 0;

-- 增量同步
SELECT * FROM users WHERE version > 100;
```

**适用场景**:
- 表有版本号字段
- 每次修改都会更新版本号
- 需要追踪数据变更历史

---

## 🔧 数据模型设计

### 任务配置扩展

```go
// 同步配置
type SyncConfig struct {
    ThreadCount int    `json:"thread_count"`
    BatchSize   int    `json:"batch_size"`
    ErrorStrategy string `json:"error_strategy"`
    
    // 新增：同步模式
    SyncMode string `json:"sync_mode"` // full/skipCompleted/incremental
    
    // 新增：增量同步配置（可选）
    IncrementalConfig *IncrementalConfig `json:"incremental_config,omitempty"`
}

// 增量同步配置
type IncrementalConfig struct {
    Strategy     string `json:"strategy"`      // timestamp/autoIncrement/version
    Field        string `json:"field"`         // 增量字段名
    InitialValue string `json:"initial_value"` // 初始值
}
```

### 任务单元状态扩展

```go
// 任务单元运行记录
type TaskUnitRuntime struct {
    ID               string     `gorm:"primaryKey;size:36" json:"id"`
    TaskID           string     `gorm:"size:36;not null" json:"task_id"`
    UnitName         string     `gorm:"size:200;not null" json:"unit_name"`
    Status           string     `gorm:"size:20;not null" json:"status"`
    TotalRecords     int64      `gorm:"default:0" json:"total_records"`
    ProcessedRecords int64      `gorm:"default:0" json:"processed_records"`
    
    // 新增：增量同步状态
    LastSyncValue *string    `gorm:"type:text" json:"last_sync_value"` // 上次同步的最大值
    LastSyncTime  *time.Time `json:"last_sync_time"`                   // 上次同步时间
    
    UpdatedAt time.Time `json:"updated_at"`
}
```

---

## 🔄 执行流程

### 全量同步流程

```
用户配置: syncMode = "full"
   ↓
SyncEngine 解析配置
   ↓
TaskManager 调度
   ↓
每个任务单元:
   ├─ Source.Read() - 读取所有数据
   ├─ Sink.Write() - 写入所有数据
   └─ 完成
```

### 跳过已完成流程（当前实现）

```
用户配置: syncMode = "skipCompleted"
   ↓
SyncEngine 解析配置
   ↓
TaskManager 调度
   ├─ 过滤: status != 'completed'
   └─ 只执行未完成的单元
   ↓
每个任务单元:
   ├─ Source.Read() - 读取所有数据
   ├─ Sink.Write() - 写入所有数据
   └─ 标记为 completed
```

### 增量同步流程（待实现）

```
用户配置: 
  syncMode = "incremental"
  incrementalConfig = {
    strategy: "timestamp",
    field: "updated_at",
    initialValue: "1970-01-01 00:00:00"
  }
   ↓
SyncEngine 解析配置
   ↓
TaskManager 调度
   ↓
每个任务单元:
   ├─ 从数据库读取 last_sync_value
   │   └─ 如果为空，使用 initialValue
   ↓
   ├─ Source.ReadIncremental(field, last_sync_value)
   │   └─ SQL: WHERE updated_at > '2026-02-27 10:00:00'
   ↓
   ├─ Sink.Write() - 写入增量数据
   ↓
   ├─ 记录本次同步的最大值
   │   └─ last_sync_value = MAX(updated_at)
   ↓
   └─ 更新数据库
```

---

## 🎯 实现优先级

### Phase 1: 基础增量同步 ✅ 已完成

- ✅ 跳过已完成的任务单元（`skipCompleted` 模式）
- ✅ 任务单元级别的断点续传

### Phase 2: 数据级增量同步 🚧 待实现

- ⬜ 扩展数据模型
- ⬜ 扩展数据库表
- ⬜ 实现 Source 增量读取接口
- ⬜ 实现 MySQL 增量读取
- ⬜ 实现 Elasticsearch 增量读取
- ⬜ 更新 SyncEngine 解析增量配置
- ⬜ 更新 TaskManager 记录增量状态

### Phase 3: 高级功能 📅 未来

- ⬜ 支持自定义增量条件
- ⬜ 支持多字段组合增量
- ⬜ 支持删除数据的同步
- ⬜ 支持冲突解决策略

---

## 📚 相关文档

- [任务调度与断点续传](./任务调度与断点续传.md) - 任务调度机制
- [系统设计文档](../requirements.md) - 完整系统设计
- [数据库设计](../数据库设计.md) - 数据库表结构

---

**文档维护**: DataTrace 开发团队  
**最后更新**: 2026-02-27
