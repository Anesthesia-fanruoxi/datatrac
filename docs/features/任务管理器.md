# 任务管理器 (TaskManager)

## 📋 文档说明

本文档详细描述 DataTrace 系统的任务管理器设计，包括职责、功能、接口和工作流程。

**文档版本**: v2.0  
**最后更新**: 2026-02-27  
**技术栈**: Go + Gin + GORM

---

## 🎯 概述

TaskManager 是 DataTrace 系统的核心调度模块，负责统一管理和调度所有同步任务的执行。

**核心职责**:
- 📦 任务单元管理（表/索引级别）
- 🔄 并发控制（goroutine池管理）
- 📊 状态跟踪和同步
- 💾 数据库持久化（MySQL）
- 🔌 与前端实时通信（SSE）

---

## 🏗️ 架构设计

### 位置

```
后端层
  └─ 核心模块
      ├─ TaskManager      ← 本模块
      ├─ SyncEngine
      ├─ ProgressMonitor
      └─ LogSystem
```

### 依赖关系

```
TaskManager
  ├─ 依赖 Storage (数据库访问)
  ├─ 依赖 ProgressMonitor (进度推送)
  └─ 被 SyncEngine 调用
```

---

## 📦 数据结构

### TaskUnit - 任务单元

```go
type TaskUnit struct {
    ID               string  `json:"id"`                // 单元ID(表名或索引名)
    Name             string  `json:"name"`              // 单元名称
    Status           string  `json:"status"`            // 状态
    TotalRecords     int64   `json:"total_records"`     // 总记录数
    ProcessedRecords int64   `json:"processed_records"` // 已处理记录数
    Percentage       float64 `json:"percentage"`        // 进度百分比
    ErrorMessage     string  `json:"error_message"`     // 错误信息(如果失败)
}
```

### TaskUnitStatus - 任务单元状态

```go
const (
    StatusPending   = "pending"    // 等待执行
    StatusRunning   = "running"    // 执行中
    StatusCompleted = "completed"  // 已完成
    StatusFailed    = "failed"     // 失败
    StatusPaused    = "paused"     // 已暂停
)
```

---

## 🔧 核心功能

### 1. 任务单元管理

#### 1.1 从数据库加载任务单元

**功能**: 从 `task_unit_runtimes` 表加载任务单元，转换为内存格式

**流程**:
1. 调用 GORM 查询数据库
2. 将数据库记录转换为 TaskUnit 结构
3. 计算进度百分比
4. 更新内存缓存（使用sync.Map）
5. 返回任务单元列表

#### 1.2 初始化任务单元列表

**功能**: 在内存中初始化任务单元列表（用于新任务）

**流程**:
1. 为每个单元名称创建 TaskUnit 对象
2. 初始状态为 Pending
3. 存储到内存缓存

#### 1.3 获取任务单元列表

**功能**: 从内存缓存获取任务单元列表

---

### 2. 状态管理

#### 2.1 更新任务单元状态

**功能**: 更新内存中的任务单元状态

#### 2.2 更新状态并同步

**功能**: 更新状态并同步到数据库和前端

**同步流程**:
```
内存缓存 (sync.Map)
   ↓ 
数据库 (GORM Update)
   ↓ 
ProgressMonitor
   ↓ 
前端 (SSE推送)
```

---

### 3. 进度管理

#### 3.1 更新任务单元进度

**功能**: 更新内存中的任务单元进度

**计算公式**:
```
percentage = (processed / total) * 100.0
```

#### 3.2 更新进度并同步

**功能**: 更新进度并同步到数据库和前端

**更新时机**:
- 每批次处理完成后
- 定时更新（避免频繁写数据库）

---

### 4. 错误处理

#### 4.1 标记任务单元失败

**功能**: 标记任务单元为失败状态，记录错误信息

**处理策略**:
- Skip策略: 记录错误，继续执行其他单元
- Pause策略: 停止所有执行，保存断点

#### 4.2 标记失败并同步

**功能**: 标记失败并同步到数据库和前端

---

### 5. 并发控制 ⭐ 核心

#### 5.1 自动模式执行

**功能**: 自动模式执行所有未完成的任务单元

**参数**:
- `taskID`: 任务ID
- `concurrency`: 并发数（goroutine数量）
- `progressMonitor`: 进度监控器
- `processFn`: 处理单个单元的函数

**返回**: 成功执行的单元数量

**执行流程**:
```
1. 从数据库加载任务单元
   ↓
2. 过滤出未完成的单元 (status != completed)
   ↓
3. 创建并发控制 (channel + WaitGroup)
   ↓
4. 为每个单元创建goroutine
   ├─ 从channel获取许可
   ├─ 标记为Running
   ├─ 调用processFn执行
   ├─ 成功 → 标记为Completed
   ├─ 失败 → 标记为Failed
   └─ 释放channel许可
   ↓
5. 等待所有goroutine完成 (WaitGroup.Wait)
   ↓
6. 返回成功数量
```

**并发控制原理**:
```
使用带缓冲的channel作为信号量:
- channel容量 = 并发数
- 执行前: 向channel发送信号 (阻塞等待)
- 执行后: 从channel接收信号 (释放许可)
- WaitGroup: 等待所有goroutine完成
```

---

## 🔄 工作流程

### 完整执行流程

```
┌─────────────────────────────────────────────────────────┐
│ 1. SyncEngine 启动任务                                   │
│    └─ 调用 TaskManager::execute_auto_mode               │
└─────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────┐
│ 2. TaskManager 加载任务单元                              │
│    ├─ 从数据库加载 (load_task_units_from_db)            │
│    ├─ 过滤未完成单元 (status != Completed)              │
│    └─ 更新内存缓存                                       │
└─────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────┐
│ 3. TaskManager 创建并发控制                              │
│    ├─ 创建 Semaphore (concurrency)                      │
│    └─ 初始化成功计数器                                   │
└─────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────┐
│ 4. TaskManager 并发执行任务单元                          │
│    ├─ 为每个单元创建异步任务                             │
│    ├─ 获取 Semaphore 许可                               │
│    ├─ 标记为 Running                                    │
│    ├─ 调用 process_fn 执行同步                          │
│    ├─ 成功 → Completed / 失败 → Failed                  │
│    └─ 释放 Semaphore 许可                               │
└─────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────┐
│ 5. 状态同步                                              │
│    ├─ 内存缓存更新                                       │
│    ├─ 数据库持久化                                       │
│    ├─ ProgressMonitor 聚合                              │
│    └─ 前端实时更新                                       │
└─────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────┐
│ 6. 等待所有任务完成                                      │
│    └─ 返回成功执行的单元数量                             │
└─────────────────────────────────────────────────────────┘
```

---

## 📊 状态同步机制

### 三层同步架构

```
┌──────────────────────────────────────────────────────────┐
│ 第一层: 内存缓存 (sync.Map)                               │
│  - 快速读写                                               │
│  - 实时状态                                               │
│  - 线程安全                                               │
└──────────────────────────────────────────────────────────┘
                        ↓ GORM Update
┌──────────────────────────────────────────────────────────┐
│ 第二层: 数据库持久化 (task_unit_runtimes)                │
│  - 断点续传                                               │
│  - 数据一致性                                             │
│  - 事务支持                                               │
└──────────────────────────────────────────────────────────┘
                        ↓ SSE Push
┌──────────────────────────────────────────────────────────┐
│ 第三层: 前端实时显示 (Server-Sent Events)                │
│  - 用户界面                                               │
│  - 实时反馈                                               │
│  - 自动重连                                               │
└──────────────────────────────────────────────────────────┘
```

### 同步时机

| 操作 | 内存 | 数据库 | 前端 |
|------|------|--------|------|
| 启动任务 | ✅ | ✅ | ✅ |
| 单元开始 | ✅ | ✅ | ✅ |
| 进度更新 | ✅ | ✅ | ✅ |
| 单元完成 | ✅ | ✅ | ✅ |
| 单元失败 | ✅ | ✅ | ✅ |

---

## 🔌 API 接口

### 核心方法

| 方法 | 说明 | 同步方式 |
|------|------|----------|
| `LoadTaskUnitsFromDB` | 从数据库加载任务单元 | 数据库查询 |
| `InitTaskUnits` | 初始化任务单元列表 | 内存操作 |
| `GetTaskUnits` | 获取任务单元列表 | 内存读取 |
| `UpdateUnitStatus` | 更新单元状态（仅内存） | 内存操作 |
| `UpdateUnitStatusWithSync` | 更新单元状态（含同步） | 内存+数据库+SSE |
| `UpdateUnitProgress` | 更新单元进度（仅内存） | 内存操作 |
| `UpdateUnitProgressWithSync` | 更新单元进度（含同步） | 内存+数据库+SSE |
| `FailUnit` | 标记单元失败（仅内存） | 内存操作 |
| `FailUnitWithSync` | 标记单元失败（含同步） | 内存+数据库+SSE |
| `ExecuteAutoMode` | 自动模式执行 | 并发执行 |
| `ClearTaskUnits` | 清除任务单元 | 内存操作 |

---

## 💡 使用场景

### 场景 1: 在 SyncEngine 中使用

**流程**:
1. 加载任务配置
2. 初始化任务单元
3. 调用 TaskManager 自动模式执行
4. 传入具体的同步逻辑函数
5. 等待执行完成

### 场景 2: 进度更新

**流程**:
1. 在同步过程中，每批次处理完成后
2. 调用 UpdateUnitProgressWithSync
3. 自动同步到数据库和前端
4. 前端实时显示进度条更新

### 场景 3: 错误处理

**流程**:
1. 捕获同步过程中的错误
2. 调用 FailUnitWithSync 标记失败
3. 根据错误策略决定是否继续
4. 前端显示错误信息

---

## 🎯 设计优势

### 1. 职责单一
TaskManager 只负责任务调度和状态管理，不涉及具体的同步逻辑。

### 2. 高并发
使用 Go 的 goroutine + channel 实现高效的并发控制，充分利用系统资源。

### 3. 状态一致
三层同步机制保证内存、数据库、前端的状态一致性。

### 4. 断点续传
与 MySQL 数据库紧密集成，支持任务暂停、恢复、失败重试。

### 5. 易于扩展
通过回调函数，支持不同类型的同步逻辑（MySQL、ES等）。

### 6. 线程安全
使用 sync.Map 保证并发访问的安全性。

---

## 📚 相关文档

- [系统设计文档](../requirements.md) - 完整的系统设计
- [数据库设计](../数据库设计.md) - 三表结构设计
- [API接口设计](../03-API接口设计.md) - API接口规范
- [管道设计](../04-管道设计.md) - Pipeline核心设计

---

**文档维护**: DataTrace 开发团队  
**最后更新**: 2026-02-27
