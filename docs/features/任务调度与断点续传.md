# 任务调度与断点续传

## 📋 文档说明

本文档详细描述 DataTrace 系统的任务调度策略和断点续传机制。

**文档版本**: v2.0  
**最后更新**: 2026-02-27  
**技术栈**: Go + Gin + GORM  
**实现状态**: 设计阶段

---

## 🎯 概述

任务调度与断点续传是 DataTrace 系统的核心功能，确保数据同步任务能够高效、可靠地执行。

**核心特性**:
- ✅ 自动调度所有未完成的任务单元
- ✅ 以表/索引为单位的断点续传
- ✅ 并发控制（goroutine + channel）
- ✅ 失败重试机制

---

## 🔄 自动调度模式

### 概述

自动模式是 DataTrace 的默认且唯一的调度模式。任务启动后，TaskManager 会自动调度所有未完成的任务单元，按照配置的并发数执行。

### 工作原理

```
任务启动
   ↓
加载所有任务单元（从MySQL数据库）
   ↓
过滤未完成单元（status != completed）
   ↓
创建并发控制（channel + WaitGroup）
   ↓
并发执行所有未完成单元
   ├─ 单元1: pending → running → completed
   ├─ 单元2: pending → running → completed
   ├─ 单元3: pending → running → failed
   └─ ...
   ↓
所有单元完成
   ↓
任务完成
```

### 示例场景

**场景**: 100 个索引，10 个并发

```
启动时状态:
- 已完成: 20 个
- 待执行: 80 个

执行过程:
1. 同时执行 10 个索引（channel满）
2. 完成 1 个后，自动开始下一个
3. 循环执行直到 80 个全部完成

最终状态:
- 已完成: 100 个
- 待执行: 0 个
```

### 并发控制

使用 Go 的 channel 作为信号量实现并发控制：

**核心思路**:
```go
// 创建带缓冲的channel作为信号量
sem := make(chan struct{}, concurrency)
var wg sync.WaitGroup

for _, unit := range pendingUnits {
    wg.Add(1)
    sem <- struct{}{} // 获取许可（阻塞等待）
    
    go func(u TaskUnit) {
        defer wg.Done()
        defer func() { <-sem }() // 释放许可
        
        // 执行同步逻辑
        syncUnit(u)
    }(unit)
}

wg.Wait() // 等待所有goroutine完成
```

**优势**:
- 自动管理并发数
- 避免资源耗尽
- 充分利用系统资源
- 简单高效

---

## 💾 断点续传机制

### 概述

断点续传功能确保任务在暂停、断网、崩溃后能够继续执行，避免重复同步已完成的数据。

**粒度**: 以表/索引为单位（不是记录级别）

### 核心原理

#### 1. 三表结构支持

```
sync_tasks (任务主表)
   ↓ 1:N
task_unit_configs (配置表)
   ↓ 1:1
task_unit_runtimes (运行记录表)
```

**说明**:
- `task_unit_configs`: 存储要同步的表/索引列表（从任务配置提取）
- `task_unit_runtimes`: 存储每个单元的执行状态和进度

#### 2. 状态定义

```rust
pub enum TaskUnitStatus {
    Pending,    // 待执行
    Running,    // 执行中
    Completed,  // 已完成
    Failed,     // 失败
    Paused,     // 已暂停
}
```

#### 3. 断点续传逻辑

| 原状态 | 任务重启后 | 说明 |
|--------|-----------|------|
| Completed | 保持 Completed | 不会重新执行 |
| Pending | 保持 Pending | 等待执行 |
| Running | 重置为 Pending | 异常中断，重新执行 |
| Failed | 保持 Failed | 等待手动重置 |
| Paused | 保持 Paused | 等待恢复 |

**注意**: 断点续传是以整个表/索引为单位，不是记录级别。即使表/索引执行到一半中断，下次也会从头开始。

### 初始化流程

```
1. TaskLoader::init_task_units
   ↓
2. 从 task_unit_configs 读取配置
   ↓
3. 加载现有的 task_unit_runtimes
   ↓
4. 对比配置和运行记录
   ├─ 已有记录 → 保持状态（Running 重置为 Pending）
   └─ 无记录 → 创建新记录（状态为 Pending）
   ↓
5. 清理孤立的运行记录
   ↓
6. 完成初始化
```

### 实现思路

**初始化任务单元流程**:

1. 从 `task_unit_configs` 表读取所有单元配置
2. 从 `task_unit_runtimes` 表加载现有的运行记录
3. 对比配置和运行记录:
   - 已有记录且状态为 Running → 重置为 Pending (异常中断)
   - 已有记录且状态为 Completed → 保持不变
   - 已有记录且其他状态 → 保持不变
   - 无记录 → 创建新的运行记录 (状态为 Pending)
4. 清理配置表中不存在的运行记录 (孤立记录)

**Go 实现要点**:
- 使用 GORM 进行数据库操作
- 使用 map 存储运行记录便于查找
- 使用事务保证数据一致性

### 使用场景

#### 场景 1: 正常暂停恢复

```
初始状态:
- 索引A: Completed
- 索引B: Running (50%)
- 索引C: Pending

用户暂停任务
   ↓
状态变化:
- 索引A: Completed
- 索引B: Paused (50%)
- 索引C: Pending

用户恢复任务
   ↓
初始化后:
- 索引A: Completed (跳过)
- 索引B: Pending (重新执行)
- 索引C: Pending

执行结果:
- 索引A: 不执行
- 索引B: 从头开始
- 索引C: 从头开始
```

#### 场景 2: 异常中断恢复

```
初始状态:
- 索引A: Completed
- 索引B: Running (80%)
- 索引C: Running (30%)

程序崩溃
   ↓
重新启动任务
   ↓
初始化后:
- 索引A: Completed (跳过)
- 索引B: Pending (重新执行)
- 索引C: Pending (重新执行)

执行结果:
- 索引A: 不执行
- 索引B: 从头开始
- 索引C: 从头开始
```

#### 场景 3: 失败重试

```
初始状态:
- 索引A: Completed
- 索引B: Failed (网络错误)
- 索引C: Pending

用户重置失败单元
   ↓
状态变化:
- 索引A: Completed
- 索引B: Pending
- 索引C: Pending

重新启动任务
   ↓
执行结果:
- 索引A: 不执行
- 索引B: 重新执行
- 索引C: 执行
```

---

## 🔧 失败处理

### 失败策略

当任务单元执行失败时：

1. **标记失败状态**
   - 调用 TaskManager 的失败标记方法
   - 更新状态为 Failed
   - 记录错误信息

2. **记录错误信息**
   - 存储到 `task_unit_runtimes.error_message`
   - 通过 SSE 推送到前端显示

3. **继续执行其他单元**
   - 失败的单元不影响其他单元
   - 其他单元继续并发执行

4. **支持手动重试**
   - 用户可以重置失败的单元
   - 重置后状态变为 Pending
   - 重新启动任务时会执行

### 重置失败单元

**API 接口**: `POST /api/v1/tasks/:id/reset-failed`

**功能**: 将任务中所有失败的单元重置为 Pending 状态

**返回**: 重置的单元数量

---

## 📊 进度跟踪

### 实时进度更新

**更新时机**: 每批次处理完成后

**更新流程**:
1. 计算已处理记录数
2. 调用 TaskManager 更新进度方法
3. 更新内存缓存
4. 持久化到数据库
5. 通过 ProgressMonitor 聚合
6. 通过 SSE 推送到前端

### 进度计算

**单个单元进度**:
```
percentage = (processed_records / total_records) * 100.0
```

**任务总体进度**:
```
percentage = (completed_units / total_units) * 100.0
```

### 进度推送

```
TaskManager
   ↓ UpdateUnitProgressWithSync
数据库持久化 (GORM Update)
   ↓
ProgressMonitor
   ↓ 聚合所有单元进度
SSE 推送
   ↓ /api/v1/tasks/:id/progress/stream
前端实时更新
```

---

## 🎯 设计优势

### 1. 可靠性
- 数据库持久化保证状态不丢失
- 支持异常中断恢复
- 失败单元不影响其他单元

### 2. 高效性
- 并发执行充分利用资源
- 已完成单元不重复执行
- 自动调度无需人工干预

### 3. 灵活性
- 支持暂停/恢复
- 支持失败重试
- 可配置并发数

### 4. 可观测性
- 实时进度反馈
- 详细错误信息
- 完整执行日志

---

## 🚫 已废弃功能

### 手动模式（已废弃）

**原设计**: 用户手动选择要执行的表/索引，支持队列排序

**废弃原因**:
- 增加系统复杂度
- 用户操作繁琐
- 自动模式已满足需求

**相关代码**: 
- `task_execution_queue` 表（已不使用）
- `execute_manual_mode` 方法（已不使用）
- 队列管理 API（已不使用）

**注意**: 虽然代码中可能还存在相关实现，但已不再维护和使用。

---

## 📚 相关文档

- [任务管理器](./任务管理器.md) - TaskManager 详细设计
- [自动模式实现](../implementation/自动模式实现.md) - 自动模式执行流程
- [断点续传实现](../implementation/断点续传实现.md) - 断点续传实现细节
- [数据库设计](../architecture/数据库设计.md) - 三表结构设计

---

**文档维护**: DataTrace 开发团队  
**最后更新**: 2026-02-27
