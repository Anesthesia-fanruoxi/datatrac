# 任务调度与断点续传功能设计

## 一、功能概述

实现灵活的任务调度系统,支持自动/手动两种同步模式,并提供断点续传能力。

## 二、核心功能

### 2.1 断点续传
- **目标**: 支持任务暂停、断网后继续同步
- **粒度**: 以表/索引为维度记录进度
- **持久化**: 使用 SQLite 数据库存储进度信息
  - **原因**: 
    - 数据库支持事务,保证数据一致性
    - 便于查询和统计
    - 与现有的任务/数据源存储方式一致
    - 支持并发读写

**断点续传逻辑**:
- **已完成(completed)**: 不会重新执行,不进入队列
- **未完成(pending/paused)**: 下次启动时重新开始
- **进行中(running)**: 如果任务中断,下次启动时重新开始
- **失败(failed)**: 下次启动时重新开始

**注意**: 断点续传是以整个表/索引为单位,不是记录级别的续传。即使表/索引执行到一半中断,下次也会从头开始。

### 2.2 自动同步模式(默认)
- 任务启动后,任务管理器自动调度所有配置的表/索引
- 按照配置的线程数并发执行
- 循环执行直到所有表/索引完成

**示例**: 100个索引,10个线程
- 同时执行10个索引
- 完成1个后,自动开始下一个
- 直到100个全部完成

### 2.3 手动同步模式
- 任务启动后不自动执行
- 用户手动选择表/索引加入执行队列
- 支持拖拽调整执行顺序
- 任务管理器按队列顺序和线程数执行

**示例**: 100个索引,10个线程
- 启动任务后,所有索引处于"待选择"状态
- 用户手动添加索引A、B、C到队列
- 任务管理器开始执行A、B、C(不超过10个线程)
- 用户可以继续添加或调整顺序

### 2.4 模式切换
- 提供"自动模式"/"手动模式"切换按钮
- 切换时机: 等待当前执行中的表/索引完成
- 启动任务时提示当前模式
### 2.5 切换时机
- 任务未开始 --随意切换
- 任务进行中，需要等待当前任务执行完成之后，等同于任务开始
手动切自动 --- 当所有进行中完成之后，会修改模式为自动（应该有个地方来记录），这个时候会加载所有任务进来有任务管理器进行统一分配
自动切手动 --- 当所有进行中完成之后，会修改模式为手动，这个时候会清空已记录的队列任务，等待手动添加进来。
+ 这个时候任务管理器会标记成不发布任务，此时所有完成的线程是不会获取到新任务，直到所有任务线程完成之后，会修改模式为手动

## 三、数据结构设计

### 3.1 任务单元进度表 (task_unit_progress)

```sql
CREATE TABLE task_unit_progress (
    id TEXT PRIMARY KEY,
    task_id TEXT NOT NULL,
    unit_name TEXT NOT NULL,           -- 表名或索引名
    unit_type TEXT NOT NULL,           -- 'table' 或 'index'
    status TEXT NOT NULL,              -- 'pending', 'running', 'completed', 'failed', 'paused'
    total_records INTEGER DEFAULT 0,   -- 总记录数
    processed_records INTEGER DEFAULT 0, -- 已处理记录数
    last_processed_id TEXT,            -- 最后处理的记录ID(用于断点续传)
    error_message TEXT,                -- 错误信息
    started_at INTEGER,                -- 开始时间(毫秒时间戳)
    completed_at INTEGER,              -- 完成时间(毫秒时间戳)
    updated_at INTEGER NOT NULL,       -- 更新时间(毫秒时间戳)
    FOREIGN KEY (task_id) REFERENCES sync_tasks(id) ON DELETE CASCADE
);

CREATE INDEX idx_task_unit_progress_task_id ON task_unit_progress(task_id);
CREATE INDEX idx_task_unit_progress_status ON task_unit_progress(status);
```

### 3.2 任务执行队列表 (task_execution_queue)

```sql
CREATE TABLE task_execution_queue (
    id TEXT PRIMARY KEY,
    task_id TEXT NOT NULL,
    unit_id TEXT NOT NULL,             -- 关联 task_unit_progress.id
    queue_order INTEGER NOT NULL,      -- 队列顺序(手动模式使用)
    added_at INTEGER NOT NULL,         -- 加入队列时间
    FOREIGN KEY (task_id) REFERENCES sync_tasks(id) ON DELETE CASCADE,
    FOREIGN KEY (unit_id) REFERENCES task_unit_progress(id) ON DELETE CASCADE
);

CREATE INDEX idx_task_execution_queue_task_id ON task_execution_queue(task_id);
CREATE INDEX idx_task_execution_queue_order ON task_execution_queue(task_id, queue_order);
```

### 3.3 任务配置扩展

在 `sync_tasks` 表中添加字段:
```sql
ALTER TABLE sync_tasks ADD COLUMN sync_mode TEXT DEFAULT 'auto'; -- 'auto' 或 'manual'
```

## 四、实现阶段

### 阶段一: 断点续传基础功能 ✅ 已完成

**完成时间**: 2026-01-28

**实现内容**:
1. ✅ 创建数据库表结构
2. ✅ 任务启动时生成所有任务单元
3. ✅ 实时更新任务单元进度
4. ✅ 支持暂停/继续功能
5. ✅ 前端显示所有任务单元及进度

**涉及文件**:
- 后端: `src-tauri/src/storage/models.rs` (数据模型)
- 后端: `src-tauri/src/storage/task_unit_ops.rs` (新建,任务单元操作)
- 后端: `src-tauri/src/task_manager.rs` (重构,任务管理器改造)
- 后端: `src-tauri/src/sync_engine/mod.rs` (添加初始化逻辑)
- 后端: `src-tauri/src/commands.rs` (添加 API)
- 前端: `src/types/index.ts` (类型定义)
- 前端: `src/stores/taskMonitor.ts` (添加方法)
- 前端: `src/views/TaskMonitor/composables/useTaskMonitor.ts` (集成)
- 前端: `src/views/TaskMonitor/components/ProgressPanel.vue` (进度展示)

**核心成果**:
- 数据库持久化完整
- 断点续传逻辑完整
- 前后端通信完整
- 实时状态同步完整

### 阶段二: 自动模式优化 ✅ 已完成

**完成时间**: 2026-01-28

**实现内容**:
1. ✅ 实现线程池管理 (Tokio Semaphore)
2. ✅ 自动调度任务单元 (`execute_auto_mode`)
3. ✅ 从数据库加载并过滤未完成单元
4. ✅ 并发执行控制
5. ✅ 完善进度统计

**涉及文件**:
- 后端: `src-tauri/src/task_manager.rs` (添加 `execute_auto_mode` 方法)

**核心成果**:
- 自动调度功能完整
- 线程池管理完整
- 支持断点续传的自动执行
- 实时状态同步

### 阶段三: 手动模式实现 ✅ 已完成

**完成时间**: 2026-01-28

**实现内容**:
1. ✅ 创建执行队列表 (`task_execution_queue`)
2. ✅ 实现队列 CRUD 操作
3. ✅ 手动模式执行逻辑 (`execute_manual_mode`)
4. ✅ 队列管理 API (添加/移除/清空/排序)
5. ✅ 支持按队列顺序执行

**涉及文件**:
- 后端: `src-tauri/src/storage/mod.rs` (创建队列表)
- 后端: `src-tauri/src/storage/models.rs` (队列数据模型)
- 后端: `src-tauri/src/storage/queue_ops.rs` (新建,队列操作)
- 后端: `src-tauri/src/task_manager.rs` (添加 `execute_manual_mode`)
- 后端: `src-tauri/src/commands.rs` (队列管理 API)
- 后端: `src-tauri/src/lib.rs` (注册命令)
- 前端: `src/types/index.ts` (队列类型定义)

**核心成果**:
- 执行队列管理完整
- 手动模式执行完整
- 支持队列顺序调整
- API 接口完整

**待实现**:
- ⏳ 前端队列管理界面
- ⏳ 拖拽排序功能
- ⏳ 模式切换控制

---

## 五、实施总结
1. 创建数据库表结构
2. 任务启动时生成所有任务单元
3. 实时更新任务单元进度
4. 支持暂停/继续功能
5. 前端显示所有任务单元及进度

**涉及文件**:
- 后端: `src-tauri/src/storage/models.rs` (数据模型)
- 后端: `src-tauri/src/storage/task_unit_ops.rs` (新建,任务单元操作)
- 后端: `src-tauri/src/task_manager.rs` (任务管理器改造)
- 前端: `src/types/index.ts` (类型定义)
- 前端: `src/views/TaskMonitor/components/ProgressPanel.vue` (进度展示)

### 阶段二: 自动模式优化
1. 实现线程池管理
2. 自动调度任务单元
3. 失败重试机制
4. 完善进度统计

**涉及文件**:
- 后端: `src-tauri/src/task_manager.rs`
- 后端: `src-tauri/src/sync_engine/mod.rs`

### 阶段三: 手动模式实现
1. 实现执行队列管理
2. 前端添加手动选择界面
3. 支持拖拽调整顺序
4. 模式切换功能

**涉及文件**:
- 后端: `src-tauri/src/storage/queue_ops.rs` (新建,队列操作)
- 后端: `src-tauri/src/commands.rs` (添加队列管理命令)
- 前端: `src/views/TaskMonitor/components/QueueManager.vue` (新建,队列管理)
- 前端: `src/views/TaskMonitor/components/TaskControl.vue` (添加模式切换)

## 五、技术要点

### 5.1 断点续传实现
- MySQL: 使用 `WHERE id > last_processed_id ORDER BY id LIMIT batch_size`
- Elasticsearch: 使用 `search_after` 参数

### 5.2 并发控制
- 使用 Tokio 的 `Semaphore` 控制并发数
- 每个任务单元独立执行,互不影响

### 5.3 进度更新
- 每批次数据处理完成后更新进度
- 使用事务保证数据一致性
- 通过 Tauri 事件实时推送到前端

### 5.4 模式切换
- 设置切换标志
- 等待当前执行中的任务单元完成
- 清空或重建执行队列
- 通知前端模式已切换

## 六、用户界面设计

### 6.1 任务控制区
```
[自动模式 ▼]  [启动] [暂停] [继续]
提示: 当前为自动模式,将自动调度所有表/索引
```

### 6.2 进度面板(自动模式)
```
表/索引同步进度
总计: 100 | 等待: 80 | 进行中: 10 | 完成: 8 | 失败: 2

[索引A] ████████░░ 80% (8000/10000)
[索引B] ██████████ 100% (5000/5000) ✓
[索引C] ██░░░░░░░░ 20% (1000/5000)
...
```

### 6.3 进度面板(手动模式)
```
手动执行队列
[添加到队列] [清空队列]

待选择 (90):
□ 索引D
□ 索引E
...

执行队列 (10):
1. [索引A] ████████░░ 80% [↑] [↓] [×]
2. [索引B] ██████████ 100% ✓
3. [索引C] ██░░░░░░░░ 20% [↑] [↓] [×]
...
```

## 七、下一步行动

1. 确认设计方案
2. 开始阶段一实现
3. 测试断点续传功能
4. 逐步实现阶段二、三

---

**创建时间**: 2026-01-28
**状态**: 设计中
