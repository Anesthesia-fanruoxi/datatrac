# ä»»åŠ¡ç®¡ç†å™¨å®ç°

## ğŸ“‹ æ–‡æ¡£è¯´æ˜

æœ¬æ–‡æ¡£è¯¦ç»†æè¿° TaskManager çš„å…·ä½“å®ç°ä»£ç å’ŒæŠ€æœ¯ç»†èŠ‚ã€‚

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**æœ€åæ›´æ–°**: 2026-01-30  
**æ–‡ä»¶ä½ç½®**: `src-tauri/src/task_manager.rs`

---

## ğŸ¯ æ¦‚è¿°

TaskManager æ˜¯ä¸€ä¸ª Rust ç»“æ„ä½“ï¼Œè´Ÿè´£ç®¡ç†ä»»åŠ¡å•å…ƒçš„å†…å­˜ç¼“å­˜ã€æ•°æ®åº“åŒæ­¥å’Œå¹¶å‘æ‰§è¡Œã€‚

**æ ¸å¿ƒæŠ€æœ¯**:
- Rust å¼‚æ­¥ç¼–ç¨‹ï¼ˆTokioï¼‰
- Arc + RwLock å®ç°çº¿ç¨‹å®‰å…¨
- Semaphore å®ç°å¹¶å‘æ§åˆ¶
- SQLite æ•°æ®åº“æŒä¹…åŒ–

---

## ğŸ—ï¸ ç»“æ„å®šä¹‰

### TaskManager ç»“æ„ä½“

```rust
pub struct TaskManager {
    /// ä»»åŠ¡å•å…ƒæ˜ å°„ (task_id -> Vec<TaskUnit>) - å†…å­˜ç¼“å­˜
    task_units: Arc<RwLock<HashMap<String, Vec<TaskUnit>>>>,
    
    /// æ•°æ®åº“å­˜å‚¨ (å¯é€‰,ç”¨äºæŒä¹…åŒ–)
    storage: Option<Arc<Storage>>,
}
```

**å­—æ®µè¯´æ˜**:
- `task_units`: å†…å­˜ç¼“å­˜ï¼Œä½¿ç”¨ Arc + RwLock å®ç°çº¿ç¨‹å®‰å…¨çš„å…±äº«è®¿é—®
- `storage`: æ•°æ®åº“å­˜å‚¨ï¼Œç”¨äºæŒä¹…åŒ–ä»»åŠ¡å•å…ƒçŠ¶æ€

### TaskUnit ç»“æ„ä½“

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct TaskUnit {
    pub id: String,
    pub name: String,
    pub status: TaskUnitStatus,
    pub total_records: u64,
    pub processed_records: u64,
    pub percentage: f64,
    pub error_message: Option<String>,
}
```

### TaskUnitStatus æšä¸¾

```rust
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "lowercase")]
pub enum TaskUnitStatus {
    Pending,
    Running,
    Completed,
    Failed,
}
```

---

## ğŸ”§ æ ¸å¿ƒæ–¹æ³•å®ç°

### 1. æ„é€ å‡½æ•°

```rust
impl TaskManager {
    /// åˆ›å»ºæ–°çš„ä»»åŠ¡ç®¡ç†å™¨
    pub fn new() -> Self {
        Self {
            task_units: Arc::new(RwLock::new(HashMap::new())),
            storage: None,
        }
    }

    /// åˆ›å»ºå¸¦æ•°æ®åº“æŒä¹…åŒ–çš„ä»»åŠ¡ç®¡ç†å™¨
    pub fn with_storage(storage: Arc<Storage>) -> Self {
        Self {
            task_units: Arc::new(RwLock::new(HashMap::new())),
            storage: Some(storage),
        }
    }
    
    /// è·å– Storage å®ä¾‹
    pub fn storage(&self) -> Option<&Arc<Storage>> {
        self.storage.as_ref()
    }
}
```

---

### 2. ä»æ•°æ®åº“åŠ è½½ä»»åŠ¡å•å…ƒ

```rust
pub async fn load_task_units_from_db(&self, task_id: &str) -> Result<Vec<TaskUnit>> {
    if let Some(storage) = &self.storage {
        // ä½¿ç”¨æ–°çš„ä¸‰è¡¨ç»“æ„ï¼šä»è¿è¡Œè®°å½•è¡¨åŠ è½½
        let db_units = storage.load_unit_runtimes(task_id).await?;
        
        log::info!("[load_task_units_from_db] ä»è¿è¡Œè®°å½•è¡¨åŠ è½½åˆ° {} ä¸ªå•å…ƒ", db_units.len());
        
        // è½¬æ¢ä¸ºå†…å­˜æ ¼å¼
        let units: Vec<TaskUnit> = db_units.into_iter().map(|u| {
            let percentage = if u.total_records > 0 {
                (u.processed_records as f64 / u.total_records as f64) * 100.0
            } else {
                0.0
            };
            
            TaskUnit {
                id: u.id,
                name: u.unit_name,
                status: match u.status {
                    crate::storage::TaskUnitStatus::Pending => TaskUnitStatus::Pending,
                    crate::storage::TaskUnitStatus::Running => TaskUnitStatus::Running,
                    crate::storage::TaskUnitStatus::Completed => TaskUnitStatus::Completed,
                    crate::storage::TaskUnitStatus::Failed => TaskUnitStatus::Failed,
                    crate::storage::TaskUnitStatus::Paused => TaskUnitStatus::Pending,
                },
                total_records: u.total_records as u64,
                processed_records: u.processed_records as u64,
                percentage,
                error_message: u.error_message,
            }
        }).collect();
        
        // æ›´æ–°å†…å­˜ç¼“å­˜
        let mut cache = self.task_units.write().unwrap();
        cache.insert(task_id.to_string(), units.clone());
        
        Ok(units)
    } else {
        Ok(Vec::new())
    }
}
```

**å®ç°è¦ç‚¹**:
1. ä»æ•°æ®åº“åŠ è½½è¿è¡Œè®°å½•
2. è½¬æ¢æ•°æ®åº“æ¨¡å‹åˆ°å†…å­˜æ¨¡å‹
3. è®¡ç®—è¿›åº¦ç™¾åˆ†æ¯”
4. æ›´æ–°å†…å­˜ç¼“å­˜
5. è¿”å›ä»»åŠ¡å•å…ƒåˆ—è¡¨

---

### 3. æ›´æ–°çŠ¶æ€å¹¶åŒæ­¥

```rust
pub async fn update_unit_status_with_sync(
    &self,
    task_id: &str,
    unit_id: &str,
    status: TaskUnitStatus,
    progress_monitor: &Arc<ProgressMonitor>,
) -> Result<()> {
    // 1. æ›´æ–°å†…å­˜ç¼“å­˜
    self.update_unit_status(task_id, unit_id, status.clone());
    
    // 2. åŒæ­¥åˆ°æ•°æ®åº“
    if let Some(storage) = &self.storage {
        let db_status = match status {
            TaskUnitStatus::Pending => crate::storage::TaskUnitStatus::Pending,
            TaskUnitStatus::Running => crate::storage::TaskUnitStatus::Running,
            TaskUnitStatus::Completed => crate::storage::TaskUnitStatus::Completed,
            TaskUnitStatus::Failed => crate::storage::TaskUnitStatus::Failed,
        };
        // ä½¿ç”¨ unit_name æ›´æ–°è¿è¡Œè®°å½•è¡¨
        storage.update_runtime_status(task_id, unit_id, db_status).await?;
    }
    
    // 3. æ¨é€åˆ°å‰ç«¯
    let units = self.get_task_units(task_id);
    progress_monitor.update_task_units(task_id, units);
    
    Ok(())
}
```

**åŒæ­¥æµç¨‹**:
```
å†…å­˜ç¼“å­˜ â†’ æ•°æ®åº“ â†’ ProgressMonitor â†’ å‰ç«¯
```

---

### 4. è‡ªåŠ¨æ¨¡å¼æ‰§è¡Œ â­ æ ¸å¿ƒ

```rust
pub async fn execute_auto_mode<F, Fut>(
    &self,
    task_id: &str,
    concurrency: usize,
    progress_monitor: Arc<ProgressMonitor>,
    process_fn: F,
) -> Result<usize>
where
    F: Fn(String, String) -> Fut + Send + Sync + 'static,
    Fut: std::future::Future<Output = Result<()>> + Send,
{
    // 1. ä»æ•°æ®åº“åŠ è½½ä»»åŠ¡å•å…ƒ
    let units = self.load_task_units_from_db(task_id).await?;
    log::info!("è‡ªåŠ¨æ¨¡å¼: åŠ è½½äº† {} ä¸ªä»»åŠ¡å•å…ƒ", units.len());
    
    // 2. è¿‡æ»¤å‡ºæœªå®Œæˆçš„å•å…ƒ
    let pending_units: Vec<_> = units
        .into_iter()
        .filter(|u| u.status != TaskUnitStatus::Completed)
        .collect();
    log::info!("è‡ªåŠ¨æ¨¡å¼: éœ€è¦æ‰§è¡Œ {} ä¸ªæœªå®Œæˆçš„å•å…ƒ", pending_units.len());
    
    if pending_units.is_empty() {
        log::info!("è‡ªåŠ¨æ¨¡å¼: æ‰€æœ‰å•å…ƒå·²å®Œæˆ,æ— éœ€æ‰§è¡Œ");
        return Ok(0);
    }
    
    // 3. åŒæ­¥åˆå§‹çŠ¶æ€åˆ° ProgressMonitor
    let all_units = self.get_task_units(task_id);
    progress_monitor.update_task_units(task_id, all_units);
    
    // 4. åˆ›å»º Semaphore æ§åˆ¶å¹¶å‘
    let semaphore = Arc::new(Semaphore::new(concurrency));
    let process_fn = Arc::new(process_fn);
    let mut tasks = Vec::new();
    let success_count = Arc::new(std::sync::atomic::AtomicUsize::new(0));
    
    log::info!("è‡ªåŠ¨æ¨¡å¼: å¼€å§‹æ‰§è¡Œï¼Œå¹¶å‘æ•°: {}", concurrency);
    
    // 5. ä¸ºæ¯ä¸ªæœªå®Œæˆå•å…ƒåˆ›å»ºå¼‚æ­¥ä»»åŠ¡
    for unit in pending_units {
        let permit = semaphore.clone().acquire_owned().await?;
        let process_fn = process_fn.clone();
        let success_count = success_count.clone();
        let task_id = task_id.to_string();
        let unit_id = unit.id.clone();
        let unit_name = unit.name.clone();
        let progress_monitor = progress_monitor.clone();
        let task_manager = self.clone();
        
        // æ ‡è®°ä¸ºè¿è¡Œä¸­
        if let Err(e) = task_manager.update_unit_status_with_sync(
            &task_id, 
            &unit_id, 
            TaskUnitStatus::Running, 
            &progress_monitor
        ).await {
            log::error!("æ›´æ–°å•å…ƒçŠ¶æ€å¤±è´¥: {}", e);
        }
        
        // å¼‚æ­¥æ‰§è¡Œä»»åŠ¡
        let task = tokio::spawn(async move {
            log::info!("è‡ªåŠ¨æ¨¡å¼: å¼€å§‹æ‰§è¡Œå•å…ƒ {} ({})", unit_name, unit_id);
            
            // è°ƒç”¨å¤„ç†å‡½æ•°
            let result = process_fn(unit_id.clone(), unit_name.clone()).await;
            
            match result {
                Ok(_) => {
                    log::info!("è‡ªåŠ¨æ¨¡å¼: å•å…ƒ {} æ‰§è¡ŒæˆåŠŸ", unit_name);
                    if let Err(e) = task_manager.update_unit_status_with_sync(
                        &task_id, 
                        &unit_id, 
                        TaskUnitStatus::Completed, 
                        &progress_monitor
                    ).await {
                        log::error!("æ›´æ–°å•å…ƒçŠ¶æ€å¤±è´¥: {}", e);
                    }
                    success_count.fetch_add(1, std::sync::atomic::Ordering::SeqCst);
                }
                Err(e) => {
                    log::error!("è‡ªåŠ¨æ¨¡å¼: å•å…ƒ {} æ‰§è¡Œå¤±è´¥: {}", unit_name, e);
                    if let Err(e) = task_manager.fail_unit_with_sync(
                        &task_id, 
                        &unit_id, 
                        e.to_string(), 
                        &progress_monitor
                    ).await {
                        log::error!("æ ‡è®°å•å…ƒå¤±è´¥: {}", e);
                    }
                }
            }
            
            // é‡Šæ”¾ Semaphore è®¸å¯
            drop(permit);
        });
        
        tasks.push(task);
    }
    
    // 6. ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
    for task in tasks {
        let _ = task.await;
    }
    
    let success = success_count.load(std::sync::atomic::Ordering::SeqCst);
    let total = self.get_task_units(task_id).len();
    log::info!("è‡ªåŠ¨æ¨¡å¼: æ‰€æœ‰å•å…ƒæ‰§è¡Œå®Œæˆï¼ŒæˆåŠŸ: {}/{}", success, total);
    
    Ok(success)
}
```

**å®ç°è¦ç‚¹**:
1. åŠ è½½å¹¶è¿‡æ»¤æœªå®Œæˆå•å…ƒ
2. åˆ›å»º Semaphore æ§åˆ¶å¹¶å‘
3. ä¸ºæ¯ä¸ªå•å…ƒåˆ›å»ºå¼‚æ­¥ä»»åŠ¡
4. è·å– Semaphore è®¸å¯ï¼ˆé˜»å¡ç›´åˆ°æœ‰ç©ºé—²ï¼‰
5. æ‰§è¡ŒåŒæ­¥é€»è¾‘
6. æ›´æ–°çŠ¶æ€ï¼ˆæˆåŠŸ/å¤±è´¥ï¼‰
7. é‡Šæ”¾ Semaphore è®¸å¯
8. ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ

---

## ğŸ”„ å¹¶å‘æ§åˆ¶åŸç†

### Semaphore å·¥ä½œæœºåˆ¶

```rust
// åˆ›å»ºä¿¡å·é‡ï¼Œåˆå§‹è®¸å¯æ•°ä¸º concurrency
let semaphore = Arc::new(Semaphore::new(concurrency));

// è·å–è®¸å¯ï¼ˆå¦‚æœæ²¡æœ‰å¯ç”¨è®¸å¯ä¼šç­‰å¾…ï¼‰
let permit = semaphore.clone().acquire_owned().await?;

// æ‰§è¡Œä»»åŠ¡
do_work().await;

// é‡Šæ”¾è®¸å¯ï¼ˆè‡ªåŠ¨ï¼Œé€šè¿‡ dropï¼‰
drop(permit);
```

**ç¤ºä¾‹**: 10 ä¸ªçº¿ç¨‹ï¼Œ100 ä¸ªä»»åŠ¡

```
æ—¶åˆ» T0:
- Semaphore è®¸å¯: 10
- è¿è¡Œä¸­ä»»åŠ¡: 0

æ—¶åˆ» T1:
- 10 ä¸ªä»»åŠ¡è·å–è®¸å¯
- Semaphore è®¸å¯: 0
- è¿è¡Œä¸­ä»»åŠ¡: 10

æ—¶åˆ» T2:
- ç¬¬ 11 ä¸ªä»»åŠ¡å°è¯•è·å–è®¸å¯
- ç­‰å¾…ä¸­...ï¼ˆé˜»å¡ï¼‰

æ—¶åˆ» T3:
- ä»»åŠ¡ 1 å®Œæˆï¼Œé‡Šæ”¾è®¸å¯
- Semaphore è®¸å¯: 1
- ä»»åŠ¡ 11 è·å–è®¸å¯
- è¿è¡Œä¸­ä»»åŠ¡: 10

...å¾ªç¯ç›´åˆ°æ‰€æœ‰ä»»åŠ¡å®Œæˆ
```

---

## ğŸ¯ Clone å®ç°

```rust
impl Clone for TaskManager {
    fn clone(&self) -> Self {
        Self {
            task_units: Arc::clone(&self.task_units),
            storage: self.storage.clone(),
        }
    }
}
```

**è¯´æ˜**:
- ä½¿ç”¨ Arc::clone å…±äº«å†…å­˜ç¼“å­˜
- å¤šä¸ª TaskManager å®ä¾‹å…±äº«åŒä¸€ä»½æ•°æ®
- æ”¯æŒåœ¨å¼‚æ­¥ä»»åŠ¡ä¸­ä½¿ç”¨

---

## ğŸ’¡ ä½¿ç”¨ç¤ºä¾‹

### åœ¨ SyncEngine ä¸­ä½¿ç”¨

```rust
// åˆ›å»º TaskManager
let task_manager = TaskManager::with_storage(storage.clone());

// æ‰§è¡Œè‡ªåŠ¨æ¨¡å¼
let success_count = task_manager.execute_auto_mode(
    task_id,
    thread_count,
    progress_monitor.clone(),
    |unit_id, unit_name| {
        let engine = self.clone();
        async move {
            // æ‰§è¡Œå…·ä½“çš„åŒæ­¥é€»è¾‘
            engine.sync_single_unit(&unit_name).await
        }
    }
).await?;

log::info!("ä»»åŠ¡å®Œæˆï¼ŒæˆåŠŸ: {}", success_count);
```

### æ›´æ–°è¿›åº¦

```rust
// åœ¨åŒæ­¥è¿‡ç¨‹ä¸­æ›´æ–°è¿›åº¦
for batch_num in 1..=total_batches {
    // å¤„ç†æ‰¹æ¬¡
    process_batch(batch_num).await?;
    
    // æ›´æ–°è¿›åº¦
    let processed = batch_num * batch_size;
    task_manager.update_unit_progress_with_sync(
        task_id,
        unit_id,
        total_records,
        processed,
        &progress_monitor
    ).await?;
}
```

---

## ğŸ” æ€§èƒ½ä¼˜åŒ–

### 1. å†…å­˜ç¼“å­˜
- ä½¿ç”¨ HashMap ç¼“å­˜ä»»åŠ¡å•å…ƒ
- é¿å…é¢‘ç¹çš„æ•°æ®åº“æŸ¥è¯¢
- è¯»å†™é”ä¿è¯çº¿ç¨‹å®‰å…¨

### 2. æ‰¹é‡æ“ä½œ
- æ‰¹é‡åŠ è½½ä»»åŠ¡å•å…ƒ
- æ‰¹é‡æ›´æ–°çŠ¶æ€
- å‡å°‘æ•°æ®åº“å¾€è¿”

### 3. å¼‚æ­¥å¹¶å‘
- ä½¿ç”¨ Tokio å¼‚æ­¥è¿è¡Œæ—¶
- Semaphore æ§åˆ¶å¹¶å‘æ•°
- å……åˆ†åˆ©ç”¨ç³»ç»Ÿèµ„æº

---

## ğŸ“š ç›¸å…³æ–‡æ¡£

- [ä»»åŠ¡ç®¡ç†å™¨](../features/ä»»åŠ¡ç®¡ç†å™¨.md) - åŠŸèƒ½è®¾è®¡
- [è‡ªåŠ¨æ¨¡å¼å®ç°](./è‡ªåŠ¨æ¨¡å¼å®ç°.md) - è‡ªåŠ¨æ¨¡å¼æ‰§è¡Œæµç¨‹
- [æ•°æ®åº“è®¾è®¡](../architecture/æ•°æ®åº“è®¾è®¡.md) - ä¸‰è¡¨ç»“æ„è®¾è®¡

---

**æ–‡æ¡£ç»´æŠ¤**: DataTrac å¼€å‘å›¢é˜Ÿ  
**æœ€åæ›´æ–°**: 2026-01-30
