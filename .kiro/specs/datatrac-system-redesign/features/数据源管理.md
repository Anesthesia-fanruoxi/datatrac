# æ•°æ®æºç®¡ç†

## ğŸ“‹ æ–‡æ¡£è¯´æ˜

æœ¬æ–‡æ¡£è¯¦ç»†æè¿°æ•°æ®æºç®¡ç†çš„ä¸šåŠ¡é€»è¾‘å’Œå®ç°ç»†èŠ‚ã€‚

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**æœ€åæ›´æ–°**: 2026-01-30  
**å®ç°çŠ¶æ€**: âœ… å·²å®Œæˆ

---

## ğŸ¯ æ¦‚è¿°

æ•°æ®æºç®¡ç†æ¨¡å—è´Ÿè´£ MySQL å’Œ Elasticsearch æ•°æ®æºçš„å¢åˆ æ”¹æŸ¥ã€è¿æ¥æµ‹è¯•å’Œå¯†ç åŠ å¯†å­˜å‚¨ã€‚

**æ ¸å¿ƒåŠŸèƒ½**:
- åˆ›å»ºæ•°æ®æº
- ç¼–è¾‘æ•°æ®æº
- åˆ é™¤æ•°æ®æº
- æµ‹è¯•è¿æ¥
- æŸ¥è¯¢æ•°æ®åº“/è¡¨/ç´¢å¼•

---

## ğŸ“Š æ•°æ®æ¨¡å‹

### DataSource ç»“æ„

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct DataSource {
    pub id: String,                    // UUID
    pub name: String,                  // æ•°æ®æºåç§°
    pub r#type: DataSourceType,        // ç±»å‹ï¼ˆmysql/elasticsearchï¼‰
    pub host: String,                  // ä¸»æœºåœ°å€
    pub port: u16,                     // ç«¯å£å·
    pub username: String,              // ç”¨æˆ·å
    pub password: String,              // å¯†ç ï¼ˆåŠ å¯†å­˜å‚¨ï¼‰
    pub database_name: Option<String>, // æ•°æ®åº“åï¼ˆMySQLä¸“ç”¨ï¼‰
    pub created_at: String,            // åˆ›å»ºæ—¶é—´
    pub updated_at: String,            // æ›´æ–°æ—¶é—´
}
```

### DataSourceType æšä¸¾

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub enum DataSourceType {
    Mysql,
    Elasticsearch,
}
```

---

## ğŸ”§ æ ¸å¿ƒä¸šåŠ¡é€»è¾‘

### 1. åˆ›å»ºæ•°æ®æº

#### 1.1 ä¸šåŠ¡æµç¨‹

```
å‰ç«¯æäº¤åˆ›å»ºè¯·æ±‚
   â†“
åç«¯æ¥æ”¶è¯·æ±‚æ•°æ®
   â†“
éªŒè¯æ•°æ®å®Œæ•´æ€§
   â”œâ”€ æ£€æŸ¥å¿…å¡«å­—æ®µ
   â”œâ”€ éªŒè¯ç«¯å£èŒƒå›´
   â””â”€ éªŒè¯åç§°å”¯ä¸€æ€§
   â†“
ç”Ÿæˆ UUID
   â†“
åŠ å¯†å¯†ç ï¼ˆAES-256-GCMï¼‰
   â†“
æ„å»º DataSource å¯¹è±¡
   â†“
ä¿å­˜åˆ°æ•°æ®åº“
   â†“
è¿”å›åˆ›å»ºçš„æ•°æ®æºï¼ˆå¯†ç å·²è§£å¯†ï¼‰
```

#### 1.2 å®ç°ä»£ç 

**åç«¯ Command**:
```rust
#[tauri::command]
pub async fn create_data_source(
    data: CreateDataSourceRequest,
    state: State<'_, AppState>,
) -> Result<DataSource, String> {
    let storage = &state.storage;
    let crypto = &state.crypto;
    
    // 1. éªŒè¯æ•°æ®
    validate_data_source_request(&data)?;
    
    // 2. æ£€æŸ¥åç§°å”¯ä¸€æ€§
    let existing = storage.find_data_source_by_name(&data.name).await
        .map_err(|e| e.to_string())?;
    if existing.is_some() {
        return Err("æ•°æ®æºåç§°å·²å­˜åœ¨".to_string());
    }
    
    // 3. ç”Ÿæˆ ID
    let id = uuid::Uuid::new_v4().to_string();
    
    // 4. åŠ å¯†å¯†ç 
    let encrypted_password = crypto.encrypt(&data.password)
        .map_err(|e| format!("å¯†ç åŠ å¯†å¤±è´¥: {}", e))?;
    
    // 5. æ„å»ºæ•°æ®æºå¯¹è±¡
    let now = chrono::Utc::now().to_rfc3339();
    let data_source = DataSource {
        id: id.clone(),
        name: data.name,
        r#type: data.r#type,
        host: data.host,
        port: data.port,
        username: data.username,
        password: encrypted_password,
        database_name: data.database_name,
        created_at: now.clone(),
        updated_at: now,
    };
    
    // 6. ä¿å­˜åˆ°æ•°æ®åº“
    storage.save_data_source(&data_source).await
        .map_err(|e| format!("ä¿å­˜å¤±è´¥: {}", e))?;
    
    // 7. è¿”å›æ•°æ®æºï¼ˆå¯†ç è§£å¯†ï¼‰
    let mut result = data_source.clone();
    result.password = crypto.decrypt(&data_source.password)
        .map_err(|e| format!("å¯†ç è§£å¯†å¤±è´¥: {}", e))?;
    
    Ok(result)
}
```

**éªŒè¯å‡½æ•°**:
```rust
fn validate_data_source_request(data: &CreateDataSourceRequest) -> Result<(), String> {
    // éªŒè¯åç§°
    if data.name.trim().is_empty() {
        return Err("æ•°æ®æºåç§°ä¸èƒ½ä¸ºç©º".to_string());
    }
    if data.name.len() < 2 || data.name.len() > 50 {
        return Err("æ•°æ®æºåç§°é•¿åº¦åº”åœ¨ 2-50 å­—ç¬¦ä¹‹é—´".to_string());
    }
    
    // éªŒè¯ä¸»æœº
    if data.host.trim().is_empty() {
        return Err("ä¸»æœºåœ°å€ä¸èƒ½ä¸ºç©º".to_string());
    }
    
    // éªŒè¯ç«¯å£
    if data.port == 0 {
        return Err("ç«¯å£å·æ— æ•ˆ".to_string());
    }
    
    // éªŒè¯ç”¨æˆ·å
    if data.username.trim().is_empty() {
        return Err("ç”¨æˆ·åä¸èƒ½ä¸ºç©º".to_string());
    }
    
    // éªŒè¯å¯†ç 
    if data.password.trim().is_empty() {
        return Err("å¯†ç ä¸èƒ½ä¸ºç©º".to_string());
    }
    
    // MySQL å¿…é¡»æä¾›æ•°æ®åº“å
    if matches!(data.r#type, DataSourceType::Mysql) && data.database_name.is_none() {
        return Err("MySQL æ•°æ®æºå¿…é¡»æŒ‡å®šæ•°æ®åº“å".to_string());
    }
    
    Ok(())
}
```

---

### 2. ç¼–è¾‘æ•°æ®æº

#### 2.1 ä¸šåŠ¡æµç¨‹

```
å‰ç«¯æäº¤ç¼–è¾‘è¯·æ±‚
   â†“
åç«¯æ¥æ”¶è¯·æ±‚æ•°æ®
   â†“
éªŒè¯æ•°æ®æºæ˜¯å¦å­˜åœ¨
   â†“
éªŒè¯æ•°æ®å®Œæ•´æ€§
   â†“
æ£€æŸ¥åç§°å”¯ä¸€æ€§ï¼ˆæ’é™¤è‡ªèº«ï¼‰
   â†“
å¦‚æœå¯†ç æœ‰å˜åŒ–ï¼Œé‡æ–°åŠ å¯†
   â†“
æ›´æ–°æ•°æ®æºå¯¹è±¡
   â†“
ä¿å­˜åˆ°æ•°æ®åº“
   â†“
è¿”å›æ›´æ–°åçš„æ•°æ®æº
```

#### 2.2 å®ç°ä»£ç 

```rust
#[tauri::command]
pub async fn update_data_source(
    id: String,
    data: UpdateDataSourceRequest,
    state: State<'_, AppState>,
) -> Result<DataSource, String> {
    let storage = &state.storage;
    let crypto = &state.crypto;
    
    // 1. æŸ¥è¯¢ç°æœ‰æ•°æ®æº
    let mut data_source = storage.load_data_source(&id).await
        .map_err(|e| e.to_string())?
        .ok_or_else(|| "æ•°æ®æºä¸å­˜åœ¨".to_string())?;
    
    // 2. éªŒè¯æ•°æ®
    validate_data_source_request(&data)?;
    
    // 3. æ£€æŸ¥åç§°å”¯ä¸€æ€§ï¼ˆæ’é™¤è‡ªèº«ï¼‰
    if data.name != data_source.name {
        let existing = storage.find_data_source_by_name(&data.name).await
            .map_err(|e| e.to_string())?;
        if existing.is_some() {
            return Err("æ•°æ®æºåç§°å·²å­˜åœ¨".to_string());
        }
    }
    
    // 4. æ›´æ–°å­—æ®µ
    data_source.name = data.name;
    data_source.host = data.host;
    data_source.port = data.port;
    data_source.username = data.username;
    data_source.database_name = data.database_name;
    data_source.updated_at = chrono::Utc::now().to_rfc3339();
    
    // 5. å¦‚æœå¯†ç æœ‰å˜åŒ–ï¼Œé‡æ–°åŠ å¯†
    if let Some(new_password) = data.password {
        if !new_password.is_empty() {
            data_source.password = crypto.encrypt(&new_password)
                .map_err(|e| format!("å¯†ç åŠ å¯†å¤±è´¥: {}", e))?;
        }
    }
    
    // 6. ä¿å­˜åˆ°æ•°æ®åº“
    storage.update_data_source(&data_source).await
        .map_err(|e| format!("æ›´æ–°å¤±è´¥: {}", e))?;
    
    // 7. è¿”å›æ•°æ®æºï¼ˆå¯†ç è§£å¯†ï¼‰
    let mut result = data_source.clone();
    result.password = crypto.decrypt(&data_source.password)
        .map_err(|e| format!("å¯†ç è§£å¯†å¤±è´¥: {}", e))?;
    
    Ok(result)
}
```

---

### 3. åˆ é™¤æ•°æ®æº

#### 3.1 ä¸šåŠ¡æµç¨‹

```
å‰ç«¯æäº¤åˆ é™¤è¯·æ±‚
   â†“
åç«¯æ¥æ”¶æ•°æ®æº ID
   â†“
æ£€æŸ¥æ•°æ®æºæ˜¯å¦è¢«ä»»åŠ¡ä½¿ç”¨
   â”œâ”€ è¢«ä½¿ç”¨ â†’ è¿”å›é”™è¯¯
   â””â”€ æœªä½¿ç”¨ â†’ ç»§ç»­
   â†“
ä»æ•°æ®åº“åˆ é™¤
   â†“
è¿”å›æˆåŠŸ
```

#### 3.2 å®ç°ä»£ç 

```rust
#[tauri::command]
pub async fn delete_data_source(
    id: String,
    state: State<'_, AppState>,
) -> Result<(), String> {
    let storage = &state.storage;
    
    // 1. æ£€æŸ¥æ˜¯å¦è¢«ä»»åŠ¡ä½¿ç”¨
    let tasks = storage.find_tasks_by_data_source(&id).await
        .map_err(|e| e.to_string())?;
    
    if !tasks.is_empty() {
        return Err(format!(
            "æ•°æ®æºæ­£åœ¨è¢« {} ä¸ªä»»åŠ¡ä½¿ç”¨ï¼Œæ— æ³•åˆ é™¤",
            tasks.len()
        ));
    }
    
    // 2. åˆ é™¤æ•°æ®æº
    storage.delete_data_source(&id).await
        .map_err(|e| format!("åˆ é™¤å¤±è´¥: {}", e))?;
    
    Ok(())
}
```

---

### 4. æµ‹è¯•è¿æ¥

#### 4.1 ä¸šåŠ¡æµç¨‹

```
å‰ç«¯æäº¤æµ‹è¯•è¿æ¥è¯·æ±‚
   â†“
åç«¯æ¥æ”¶æ•°æ®æº ID
   â†“
åŠ è½½æ•°æ®æºä¿¡æ¯
   â†“
è§£å¯†å¯†ç 
   â†“
æ ¹æ®ç±»å‹åˆ›å»ºè¿æ¥
   â”œâ”€ MySQL: åˆ›å»º MySQL è¿æ¥æ± 
   â””â”€ ES: åˆ›å»º ES å®¢æˆ·ç«¯
   â†“
æ‰§è¡Œæµ‹è¯•æŸ¥è¯¢
   â”œâ”€ MySQL: SELECT 1
   â””â”€ ES: GET /
   â†“
è¿”å›æµ‹è¯•ç»“æœ
   â”œâ”€ æˆåŠŸ: è¿”å›ç‰ˆæœ¬ä¿¡æ¯
   â””â”€ å¤±è´¥: è¿”å›é”™è¯¯ä¿¡æ¯
```

#### 4.2 å®ç°ä»£ç 

```rust
#[tauri::command]
pub async fn test_data_source_connection(
    id: String,
    state: State<'_, AppState>,
) -> Result<TestConnectionResponse, String> {
    let storage = &state.storage;
    let crypto = &state.crypto;
    
    // 1. åŠ è½½æ•°æ®æº
    let data_source = storage.load_data_source(&id).await
        .map_err(|e| e.to_string())?
        .ok_or_else(|| "æ•°æ®æºä¸å­˜åœ¨".to_string())?;
    
    // 2. è§£å¯†å¯†ç 
    let password = crypto.decrypt(&data_source.password)
        .map_err(|e| format!("å¯†ç è§£å¯†å¤±è´¥: {}", e))?;
    
    // 3. æ ¹æ®ç±»å‹æµ‹è¯•è¿æ¥
    match data_source.r#type {
        DataSourceType::Mysql => {
            test_mysql_connection(&data_source, &password).await
        }
        DataSourceType::Elasticsearch => {
            test_es_connection(&data_source, &password).await
        }
    }
}

async fn test_mysql_connection(
    ds: &DataSource,
    password: &str,
) -> Result<TestConnectionResponse, String> {
    // æ„å»ºè¿æ¥å­—ç¬¦ä¸²
    let connection_string = format!(
        "mysql://{}:{}@{}:{}/{}",
        ds.username,
        password,
        ds.host,
        ds.port,
        ds.database_name.as_ref().unwrap()
    );
    
    // åˆ›å»ºè¿æ¥æ± 
    let pool = MySqlPool::connect(&connection_string).await
        .map_err(|e| format!("è¿æ¥å¤±è´¥: {}", e))?;
    
    // æ‰§è¡Œæµ‹è¯•æŸ¥è¯¢
    let row: (String,) = sqlx::query_as("SELECT VERSION()")
        .fetch_one(&pool).await
        .map_err(|e| format!("æŸ¥è¯¢å¤±è´¥: {}", e))?;
    
    // å…³é—­è¿æ¥æ± 
    pool.close().await;
    
    Ok(TestConnectionResponse {
        success: true,
        message: "è¿æ¥æˆåŠŸ".to_string(),
        version: Some(row.0),
    })
}

async fn test_es_connection(
    ds: &DataSource,
    password: &str,
) -> Result<TestConnectionResponse, String> {
    // æ„å»º ES å®¢æˆ·ç«¯
    let url = format!("http://{}:{}", ds.host, ds.port);
    let credentials = Credentials::Basic(ds.username.clone(), password.to_string());
    let transport = Transport::single_node(&url)
        .map_err(|e| format!("åˆ›å»ºå®¢æˆ·ç«¯å¤±è´¥: {}", e))?
        .auth(credentials)
        .build()
        .map_err(|e| format!("æ„å»ºå®¢æˆ·ç«¯å¤±è´¥: {}", e))?;
    
    let client = Elasticsearch::new(transport);
    
    // æ‰§è¡Œæµ‹è¯•æŸ¥è¯¢
    let response = client.info().send().await
        .map_err(|e| format!("è¿æ¥å¤±è´¥: {}", e))?;
    
    let body = response.json::<serde_json::Value>().await
        .map_err(|e| format!("è§£æå“åº”å¤±è´¥: {}", e))?;
    
    let version = body["version"]["number"]
        .as_str()
        .unwrap_or("unknown")
        .to_string();
    
    Ok(TestConnectionResponse {
        success: true,
        message: "è¿æ¥æˆåŠŸ".to_string(),
        version: Some(version),
    })
}
```

---

### 5. æŸ¥è¯¢æ•°æ®åº“åˆ—è¡¨ï¼ˆMySQLï¼‰

#### 5.1 ä¸šåŠ¡æµç¨‹

```
å‰ç«¯æäº¤æŸ¥è¯¢è¯·æ±‚
   â†“
åç«¯æ¥æ”¶æ•°æ®æº ID
   â†“
åˆ›å»º MySQL è¿æ¥
   â†“
æ‰§è¡ŒæŸ¥è¯¢: SHOW DATABASES
   â†“
è¿‡æ»¤ç³»ç»Ÿæ•°æ®åº“
   â†“
è¿”å›æ•°æ®åº“åˆ—è¡¨
```

#### 5.2 å®ç°ä»£ç 

```rust
#[tauri::command]
pub async fn get_databases(
    data_source_id: String,
    state: State<'_, AppState>,
) -> Result<Vec<String>, String> {
    let storage = &state.storage;
    let crypto = &state.crypto;
    
    // 1. åŠ è½½æ•°æ®æº
    let data_source = storage.load_data_source(&data_source_id).await
        .map_err(|e| e.to_string())?
        .ok_or_else(|| "æ•°æ®æºä¸å­˜åœ¨".to_string())?;
    
    // 2. éªŒè¯ç±»å‹
    if !matches!(data_source.r#type, DataSourceType::Mysql) {
        return Err("æ•°æ®æºç±»å‹ä¸æ˜¯ MySQL".to_string());
    }
    
    // 3. è§£å¯†å¯†ç 
    let password = crypto.decrypt(&data_source.password)
        .map_err(|e| format!("å¯†ç è§£å¯†å¤±è´¥: {}", e))?;
    
    // 4. åˆ›å»ºè¿æ¥
    let connection_string = format!(
        "mysql://{}:{}@{}:{}",
        data_source.username,
        password,
        data_source.host,
        data_source.port
    );
    
    let pool = MySqlPool::connect(&connection_string).await
        .map_err(|e| format!("è¿æ¥å¤±è´¥: {}", e))?;
    
    // 5. æŸ¥è¯¢æ•°æ®åº“åˆ—è¡¨
    let rows: Vec<(String,)> = sqlx::query_as("SHOW DATABASES")
        .fetch_all(&pool).await
        .map_err(|e| format!("æŸ¥è¯¢å¤±è´¥: {}", e))?;
    
    // 6. è¿‡æ»¤ç³»ç»Ÿæ•°æ®åº“
    let databases: Vec<String> = rows
        .into_iter()
        .map(|(db,)| db)
        .filter(|db| !["information_schema", "mysql", "performance_schema", "sys"].contains(&db.as_str()))
        .collect();
    
    // 7. å…³é—­è¿æ¥
    pool.close().await;
    
    Ok(databases)
}
```

---

### 6. æŸ¥è¯¢è¡¨åˆ—è¡¨ï¼ˆMySQLï¼‰

#### 6.1 ä¸šåŠ¡æµç¨‹

```
å‰ç«¯æäº¤æŸ¥è¯¢è¯·æ±‚ï¼ˆæ•°æ®æº ID + æ•°æ®åº“åï¼‰
   â†“
åç«¯æ¥æ”¶å‚æ•°
   â†“
åˆ›å»º MySQL è¿æ¥
   â†“
åˆ‡æ¢åˆ°æŒ‡å®šæ•°æ®åº“
   â†“
æ‰§è¡ŒæŸ¥è¯¢: SHOW TABLES
   â†“
è¿”å›è¡¨åˆ—è¡¨
```

#### 6.2 å®ç°ä»£ç 

```rust
#[tauri::command]
pub async fn get_tables(
    data_source_id: String,
    database: String,
    state: State<'_, AppState>,
) -> Result<Vec<String>, String> {
    let storage = &state.storage;
    let crypto = &state.crypto;
    
    // 1. åŠ è½½æ•°æ®æº
    let data_source = storage.load_data_source(&data_source_id).await
        .map_err(|e| e.to_string())?
        .ok_or_else(|| "æ•°æ®æºä¸å­˜åœ¨".to_string())?;
    
    // 2. è§£å¯†å¯†ç 
    let password = crypto.decrypt(&data_source.password)
        .map_err(|e| format!("å¯†ç è§£å¯†å¤±è´¥: {}", e))?;
    
    // 3. åˆ›å»ºè¿æ¥ï¼ˆæŒ‡å®šæ•°æ®åº“ï¼‰
    let connection_string = format!(
        "mysql://{}:{}@{}:{}/{}",
        data_source.username,
        password,
        data_source.host,
        data_source.port,
        database
    );
    
    let pool = MySqlPool::connect(&connection_string).await
        .map_err(|e| format!("è¿æ¥å¤±è´¥: {}", e))?;
    
    // 4. æŸ¥è¯¢è¡¨åˆ—è¡¨
    let rows: Vec<(String,)> = sqlx::query_as("SHOW TABLES")
        .fetch_all(&pool).await
        .map_err(|e| format!("æŸ¥è¯¢å¤±è´¥: {}", e))?;
    
    let tables: Vec<String> = rows.into_iter().map(|(table,)| table).collect();
    
    // 5. å…³é—­è¿æ¥
    pool.close().await;
    
    Ok(tables)
}
```

---

### 7. æŸ¥è¯¢ç´¢å¼•åˆ—è¡¨ï¼ˆESï¼‰

#### 7.1 ä¸šåŠ¡æµç¨‹

```
å‰ç«¯æäº¤æŸ¥è¯¢è¯·æ±‚
   â†“
åç«¯æ¥æ”¶æ•°æ®æº ID
   â†“
åˆ›å»º ES å®¢æˆ·ç«¯
   â†“
æ‰§è¡ŒæŸ¥è¯¢: GET /_cat/indices
   â†“
è§£æç´¢å¼•ä¿¡æ¯
   â†“
è¿”å›ç´¢å¼•åˆ—è¡¨
```

#### 7.2 å®ç°ä»£ç 

```rust
#[tauri::command]
pub async fn get_indices(
    data_source_id: String,
    state: State<'_, AppState>,
) -> Result<Vec<IndexInfo>, String> {
    let storage = &state.storage;
    let crypto = &state.crypto;
    
    // 1. åŠ è½½æ•°æ®æº
    let data_source = storage.load_data_source(&data_source_id).await
        .map_err(|e| e.to_string())?
        .ok_or_else(|| "æ•°æ®æºä¸å­˜åœ¨".to_string())?;
    
    // 2. éªŒè¯ç±»å‹
    if !matches!(data_source.r#type, DataSourceType::Elasticsearch) {
        return Err("æ•°æ®æºç±»å‹ä¸æ˜¯ Elasticsearch".to_string());
    }
    
    // 3. è§£å¯†å¯†ç 
    let password = crypto.decrypt(&data_source.password)
        .map_err(|e| format!("å¯†ç è§£å¯†å¤±è´¥: {}", e))?;
    
    // 4. åˆ›å»º ES å®¢æˆ·ç«¯
    let url = format!("http://{}:{}", data_source.host, data_source.port);
    let credentials = Credentials::Basic(data_source.username.clone(), password);
    let transport = Transport::single_node(&url)
        .map_err(|e| format!("åˆ›å»ºå®¢æˆ·ç«¯å¤±è´¥: {}", e))?
        .auth(credentials)
        .build()
        .map_err(|e| format!("æ„å»ºå®¢æˆ·ç«¯å¤±è´¥: {}", e))?;
    
    let client = Elasticsearch::new(transport);
    
    // 5. æŸ¥è¯¢ç´¢å¼•åˆ—è¡¨
    let response = client.cat().indices()
        .format("json")
        .send().await
        .map_err(|e| format!("æŸ¥è¯¢å¤±è´¥: {}", e))?;
    
    let indices: Vec<IndexInfo> = response.json().await
        .map_err(|e| format!("è§£æå“åº”å¤±è´¥: {}", e))?;
    
    Ok(indices)
}
```

---

## ğŸ” å¯†ç åŠ å¯†æœºåˆ¶

### åŠ å¯†ç®—æ³•
- **ç®—æ³•**: AES-256-GCM
- **å¯†é’¥**: ä»ç¯å¢ƒå˜é‡æˆ–é…ç½®æ–‡ä»¶è¯»å–
- **éšæœºæ•°**: æ¯æ¬¡åŠ å¯†ç”Ÿæˆæ–°çš„ nonce

### åŠ å¯†æµç¨‹

```
æ˜æ–‡å¯†ç 
   â†“
ç”Ÿæˆéšæœº nonce (12 å­—èŠ‚)
   â†“
ä½¿ç”¨ AES-256-GCM åŠ å¯†
   â†“
æ‹¼æ¥ nonce + å¯†æ–‡
   â†“
Base64 ç¼–ç 
   â†“
å­˜å‚¨åˆ°æ•°æ®åº“
```

### è§£å¯†æµç¨‹

```
ä»æ•°æ®åº“è¯»å–å¯†æ–‡
   â†“
Base64 è§£ç 
   â†“
åˆ†ç¦» nonce å’Œå¯†æ–‡
   â†“
ä½¿ç”¨ AES-256-GCM è§£å¯†
   â†“
è¿”å›æ˜æ–‡å¯†ç 
```

---

## ğŸ“š ç›¸å…³æ–‡æ¡£

- [æ•°æ®åº“è®¾è®¡](../architecture/æ•°æ®åº“è®¾è®¡.md) - æ•°æ®æºè¡¨ç»“æ„
- [æŠ€æœ¯è§„èŒƒ](../architecture/æŠ€æœ¯è§„èŒƒ.md) - åŠ å¯†è§„èŒƒ
- [APIæ¥å£è®¾è®¡](../architecture/APIæ¥å£è®¾è®¡.md) - æ•°æ®æº API
- [äº¤äº’è®¾è®¡](../design/äº¤äº’è®¾è®¡.md) - æ•°æ®æºç®¡ç†äº¤äº’æµç¨‹

---

**æ–‡æ¡£ç»´æŠ¤**: DataTrac å¼€å‘å›¢é˜Ÿ  
**æœ€åæ›´æ–°**: 2026-01-30
