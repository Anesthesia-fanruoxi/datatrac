# Elasticsearch ç´¢å¼•å»é‡æœºåˆ¶

## ğŸ“‹ æ–‡æ¡£è¯´æ˜

æœ¬æ–‡æ¡£è¯¦ç»†æè¿° DataTrac ç³»ç»Ÿé’ˆå¯¹ Elasticsearch ç´¢å¼•çš„å»é‡æœºåˆ¶ï¼Œé¿å…é‡å¤åŒæ­¥ç›¸åŒçš„ç´¢å¼•ã€‚

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**æœ€åæ›´æ–°**: 2026-01-30  
**å®ç°çŠ¶æ€**: ğŸš§ è®¾è®¡ä¸­

---

## ğŸ¯ é—®é¢˜åœºæ™¯

### åœºæ™¯ 1: è·¨ä»»åŠ¡çš„ç´¢å¼•é‡å¤

```
ç¬¬ä¸€æ¬¡åŒæ­¥ä»»åŠ¡:
- å…³é”®å­—: "user"
- åŒ¹é…åˆ°ç´¢å¼•: index-user-2024, index-user-2025
- åŒæ­¥å®Œæˆ âœ…

ç¬¬äºŒæ¬¡åŒæ­¥ä»»åŠ¡:
- å…³é”®å­—: "user-data"
- åŒ¹é…åˆ°ç´¢å¼•: index-user-2024, index-user-2025, index-user-data
- é—®é¢˜: index-user-2024 å’Œ index-user-2025 å·²ç»åŒæ­¥è¿‡äº† âŒ
- éœ€æ±‚: åªåŒæ­¥ index-user-dataï¼Œè·³è¿‡å·²åŒæ­¥çš„ç´¢å¼• âœ…
```

### åœºæ™¯ 2: å•æ¬¡ä»»åŠ¡å†…çš„ç´¢å¼•é‡å¤

```
ä¸€æ¬¡åŒæ­¥ä»»åŠ¡:
- å…³é”®å­—1: "user"  â†’ åŒ¹é…: index-user-2024, index-common
- å…³é”®å­—2: "common" â†’ åŒ¹é…: index-common, index-common-data
- å…³é”®å­—3: "data"  â†’ åŒ¹é…: index-common-data, index-data-2024

é—®é¢˜:
- index-common åœ¨å…³é”®å­—1å’Œ2ä¸­éƒ½å‡ºç°
- index-common-data åœ¨å…³é”®å­—2å’Œ3ä¸­éƒ½å‡ºç°

éœ€æ±‚:
1. å»é‡: æ¯ä¸ªç´¢å¼•åªåŒæ­¥ä¸€æ¬¡
2. æ ‡ç­¾: ä½¿ç”¨ç¬¬ä¸€æ¬¡å‡ºç°çš„å…³é”®å­—ä½œä¸ºæ ‡ç­¾
   - index-common â†’ æ ‡ç­¾: "user"
   - index-common-data â†’ æ ‡ç­¾: "common"
```

---

## ğŸ—ï¸ è§£å†³æ–¹æ¡ˆè®¾è®¡

### ä¸¤å±‚å»é‡æœºåˆ¶

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ç¬¬ä¸€å±‚: ä»»åŠ¡å†…å»é‡ï¼ˆå•æ¬¡æ‰§è¡Œï¼‰                            â”‚
â”‚  - æ—¶æœº: åˆ›å»ºä»»åŠ¡å•å…ƒæ—¶                                   â”‚
â”‚  - èŒƒå›´: å½“å‰ä»»åŠ¡çš„æ‰€æœ‰å…³é”®å­—                             â”‚
â”‚  - ç­–ç•¥: ä½¿ç”¨ HashSet å»é‡                               â”‚
â”‚  - æ ‡ç­¾: è®°å½•ç¬¬ä¸€æ¬¡å‡ºç°çš„å…³é”®å­—                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ç¬¬äºŒå±‚: è·¨ä»»åŠ¡å»é‡ï¼ˆå†å²è®°å½•ï¼‰                            â”‚
â”‚  - æ—¶æœº: åˆ›å»ºä»»åŠ¡å•å…ƒæ—¶                                   â”‚
â”‚  - èŒƒå›´: æ‰€æœ‰å†å²ä»»åŠ¡                                     â”‚
â”‚  - ç­–ç•¥: æŸ¥è¯¢ synced_indices è¡¨                          â”‚
â”‚  - é€‰é¡¹: æ”¯æŒå¼ºåˆ¶é‡æ–°åŒæ­¥                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ”§ æ•°æ®æ¨¡å‹è®¾è®¡

### 1. ä»»åŠ¡é…ç½®æ‰©å±•

```rust
/// ä»»åŠ¡é…ç½®
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct TaskConfig {
    // åŸæœ‰å­—æ®µ
    pub units: Vec<String>,
    pub sync_config: SyncConfig,
    
    // æ–°å¢å­—æ®µ
    #[serde(skip_serializing_if = "Option::is_none")]
    pub keywords: Option<Vec<KeywordMapping>>,  // å…³é”®å­—æ˜ å°„
    
    #[serde(default)]
    pub skip_synced: bool,  // æ˜¯å¦è·³è¿‡å·²åŒæ­¥çš„ç´¢å¼•ï¼ˆé»˜è®¤ trueï¼‰
}

/// å…³é”®å­—æ˜ å°„
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct KeywordMapping {
    pub keyword: String,      // å…³é”®å­—
    pub indices: Vec<String>, // åŒ¹é…åˆ°çš„ç´¢å¼•åˆ—è¡¨
}
```

**JSON ç¤ºä¾‹**ï¼š
```json
{
  "units": [
    "index-user-2024",
    "index-common",
    "index-common-data",
    "index-data-2024"
  ],
  "keywords": [
    {
      "keyword": "user",
      "indices": ["index-user-2024", "index-common"]
    },
    {
      "keyword": "common",
      "indices": ["index-common", "index-common-data"]
    },
    {
      "keyword": "data",
      "indices": ["index-common-data", "index-data-2024"]
    }
  ],
  "skipSynced": true,
  "syncConfig": {
    "threadCount": 4,
    "batchSize": 5000
  }
}
```

### 2. ä»»åŠ¡å•å…ƒæ‰©å±•

```rust
/// ä»»åŠ¡å•å…ƒ
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct TaskUnit {
    pub id: String,
    pub task_id: String,
    pub unit_name: String,
    pub unit_type: TaskUnitType,
    pub status: String,
    pub total_records: i64,
    pub processed_records: i64,
    pub error_message: Option<String>,
    
    // æ–°å¢å­—æ®µ
    pub keyword: Option<String>,  // å…³è”çš„å…³é”®å­—ï¼ˆæ ‡ç­¾ï¼‰
    
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}
```

### 3. å·²åŒæ­¥ç´¢å¼•è¡¨

```sql
-- æ–°å¢è¡¨: è®°å½•å·²åŒæ­¥çš„ç´¢å¼•
CREATE TABLE IF NOT EXISTS synced_indices (
    id TEXT PRIMARY KEY,
    source_id TEXT NOT NULL,        -- æ•°æ®æº ID
    index_name TEXT NOT NULL,       -- ç´¢å¼•åç§°
    first_synced_at INTEGER NOT NULL,  -- é¦–æ¬¡åŒæ­¥æ—¶é—´
    last_synced_at INTEGER NOT NULL,   -- æœ€ååŒæ­¥æ—¶é—´
    sync_count INTEGER DEFAULT 1,      -- åŒæ­¥æ¬¡æ•°
    last_task_id TEXT,                 -- æœ€ååŒæ­¥çš„ä»»åŠ¡ ID
    UNIQUE(source_id, index_name)
);

-- ç´¢å¼•
CREATE INDEX IF NOT EXISTS idx_synced_indices_source ON synced_indices(source_id);
CREATE INDEX IF NOT EXISTS idx_synced_indices_name ON synced_indices(source_id, index_name);
```

---

## ğŸ”„ æ‰§è¡Œæµç¨‹

### å®Œæ•´æµç¨‹å›¾

```
å‰ç«¯åˆ›å»ºä»»åŠ¡
   â”œâ”€ ç”¨æˆ·é€‰æ‹©å…³é”®å­—: ["user", "common", "data"]
   â”œâ”€ å‰ç«¯æŸ¥è¯¢ ESï¼Œè·å–æ¯ä¸ªå…³é”®å­—åŒ¹é…çš„ç´¢å¼•
   â””â”€ æ„å»º keywords æ˜ å°„
   â†“
åç«¯æ¥æ”¶ä»»åŠ¡é…ç½®
   â†“
TaskManager.create_task_with_units()
   â†“
1. ä»»åŠ¡å†…å»é‡
   â”œâ”€ éå†æ‰€æœ‰ keywords
   â”œâ”€ ä½¿ç”¨ HashMap<String, String> è®°å½• (ç´¢å¼• â†’ å…³é”®å­—)
   â”œâ”€ å¦‚æœç´¢å¼•å·²å­˜åœ¨ï¼Œè·³è¿‡ï¼ˆä¿ç•™ç¬¬ä¸€ä¸ªå…³é”®å­—ï¼‰
   â””â”€ å¾—åˆ°å»é‡åçš„ç´¢å¼•åˆ—è¡¨
   â†“
2. è·¨ä»»åŠ¡å»é‡ï¼ˆå¦‚æœ skipSynced = trueï¼‰
   â”œâ”€ æŸ¥è¯¢ synced_indices è¡¨
   â”œâ”€ è¿‡æ»¤æ‰å·²åŒæ­¥çš„ç´¢å¼•
   â””â”€ å¾—åˆ°æœ€ç»ˆéœ€è¦åŒæ­¥çš„ç´¢å¼•åˆ—è¡¨
   â†“
3. åˆ›å»ºä»»åŠ¡å•å…ƒ
   â”œâ”€ ä¸ºæ¯ä¸ªç´¢å¼•åˆ›å»º TaskUnit
   â”œâ”€ è®¾ç½® keyword å­—æ®µï¼ˆæ ‡ç­¾ï¼‰
   â””â”€ ä¿å­˜åˆ°æ•°æ®åº“
   â†“
4. æ‰§è¡ŒåŒæ­¥
   â”œâ”€ æ­£å¸¸æ‰§è¡ŒåŒæ­¥æµç¨‹
   â””â”€ æ¯ä¸ªå•å…ƒå®Œæˆåï¼Œè®°å½•åˆ° synced_indices
```

---

## ğŸ’» æ ¸å¿ƒå®ç°

### 1. ä»»åŠ¡å†…å»é‡

```rust
impl TaskManager {
    /// åˆ›å»ºä»»åŠ¡å¹¶ç”Ÿæˆå»é‡åçš„ä»»åŠ¡å•å…ƒ
    pub async fn create_task_with_units(
        &self,
        task: SyncTask,
        config: TaskConfig,
    ) -> Result<String> {
        // 1. ä¿å­˜ä»»åŠ¡
        self.storage.save_task(&task).await?;
        
        // 2. ä»»åŠ¡å†…å»é‡
        let deduplicated = self.deduplicate_within_task(&config)?;
        
        // 3. è·¨ä»»åŠ¡å»é‡ï¼ˆå¦‚æœå¯ç”¨ï¼‰
        let final_units = if config.skip_synced {
            self.deduplicate_across_tasks(&task.source_id, deduplicated).await?
        } else {
            deduplicated
        };
        
        // 4. åˆ›å»ºä»»åŠ¡å•å…ƒ
        for (index_name, keyword) in final_units {
            let unit = TaskUnit {
                id: uuid::Uuid::new_v4().to_string(),
                task_id: task.id.clone(),
                unit_name: index_name,
                unit_type: TaskUnitType::Index,
                status: TaskUnitStatus::Pending.as_str().to_string(),
                total_records: 0,
                processed_records: 0,
                error_message: None,
                keyword: Some(keyword),
                created_at: Utc::now(),
                updated_at: Utc::now(),
            };
            
            self.storage.save_task_unit(&unit).await?;
        }
        
        Ok(task.id)
    }
    
    /// ä»»åŠ¡å†…å»é‡
    fn deduplicate_within_task(
        &self,
        config: &TaskConfig,
    ) -> Result<Vec<(String, String)>> {
        let mut index_map: HashMap<String, String> = HashMap::new();
        
        if let Some(keywords) = &config.keywords {
            for mapping in keywords {
                for index in &mapping.indices {
                    // åªè®°å½•ç¬¬ä¸€æ¬¡å‡ºç°çš„å…³é”®å­—
                    index_map.entry(index.clone())
                        .or_insert(mapping.keyword.clone());
                }
            }
        } else {
            // å¦‚æœæ²¡æœ‰ keywordsï¼Œä½¿ç”¨ units
            for unit in &config.units {
                index_map.insert(unit.clone(), String::new());
            }
        }
        
        Ok(index_map.into_iter().collect())
    }
    
    /// è·¨ä»»åŠ¡å»é‡
    async fn deduplicate_across_tasks(
        &self,
        source_id: &str,
        units: Vec<(String, String)>,
    ) -> Result<Vec<(String, String)>> {
        let mut result = Vec::new();
        
        for (index_name, keyword) in units {
            // æ£€æŸ¥ç´¢å¼•æ˜¯å¦å·²åŒæ­¥
            let is_synced = self.storage
                .is_index_synced(source_id, &index_name)
                .await?;
            
            if !is_synced {
                result.push((index_name, keyword));
            } else {
                log::info!("è·³è¿‡å·²åŒæ­¥çš„ç´¢å¼•: {}", index_name);
            }
        }
        
        Ok(result)
    }
}
```

### 2. è®°å½•å·²åŒæ­¥ç´¢å¼•

```rust
impl TaskManager {
    /// æ ‡è®°ç´¢å¼•ä¸ºå·²åŒæ­¥
    pub async fn mark_index_synced(
        &self,
        source_id: &str,
        index_name: &str,
        task_id: &str,
    ) -> Result<()> {
        self.storage
            .mark_index_synced(source_id, index_name, task_id)
            .await
    }
}

impl Storage {
    /// æ£€æŸ¥ç´¢å¼•æ˜¯å¦å·²åŒæ­¥
    pub async fn is_index_synced(
        &self,
        source_id: &str,
        index_name: &str,
    ) -> Result<bool> {
        let row = sqlx::query(
            "SELECT COUNT(*) as count FROM synced_indices WHERE source_id = ? AND index_name = ?"
        )
        .bind(source_id)
        .bind(index_name)
        .fetch_one(&self.pool)
        .await?;
        
        let count: i64 = row.get("count");
        Ok(count > 0)
    }
    
    /// æ ‡è®°ç´¢å¼•ä¸ºå·²åŒæ­¥
    pub async fn mark_index_synced(
        &self,
        source_id: &str,
        index_name: &str,
        task_id: &str,
    ) -> Result<()> {
        let now = Utc::now().timestamp();
        
        sqlx::query(
            r#"
            INSERT INTO synced_indices (id, source_id, index_name, first_synced_at, last_synced_at, sync_count, last_task_id)
            VALUES (?, ?, ?, ?, ?, 1, ?)
            ON CONFLICT(source_id, index_name) DO UPDATE SET
                last_synced_at = excluded.last_synced_at,
                sync_count = sync_count + 1,
                last_task_id = excluded.last_task_id
            "#
        )
        .bind(uuid::Uuid::new_v4().to_string())
        .bind(source_id)
        .bind(index_name)
        .bind(now)
        .bind(now)
        .bind(task_id)
        .execute(&self.pool)
        .await?;
        
        Ok(())
    }
}
```

### 3. åŒæ­¥å®Œæˆåè®°å½•

```rust
// åœ¨ SyncEngine ä¸­ï¼Œä»»åŠ¡å•å…ƒå®Œæˆåè®°å½•
impl SyncEngine {
    pub async fn start_sync(&self, task_id: &str) -> Result<()> {
        // ... ç°æœ‰é€»è¾‘ ...
        
        let success_count = self
            .task_manager
            .execute_auto_mode(
                task_id,
                config.sync_config.thread_count,
                self.progress_monitor.clone(),
                move |_unit_id, unit_name| {
                    let source_id = task.source_id.clone();
                    let task_id = task_id.clone();
                    let task_manager = task_manager_clone.clone();
                    
                    async move {
                        // æ‰§è¡ŒåŒæ­¥
                        // ...
                        
                        // åŒæ­¥æˆåŠŸåï¼Œè®°å½•åˆ° synced_indices
                        task_manager
                            .mark_index_synced(&source_id, &unit_name, &task_id)
                            .await?;
                        
                        Ok(())
                    }
                },
            )
            .await?;
        
        Ok(())
    }
}
```

---

## ğŸ“Š é…ç½®ç¤ºä¾‹

### ç¤ºä¾‹ 1: å¯ç”¨è·¨ä»»åŠ¡å»é‡ï¼ˆé»˜è®¤ï¼‰

```json
{
  "units": [
    "index-user-2024",
    "index-common",
    "index-data-2024"
  ],
  "keywords": [
    {
      "keyword": "user",
      "indices": ["index-user-2024", "index-common"]
    },
    {
      "keyword": "data",
      "indices": ["index-common", "index-data-2024"]
    }
  ],
  "skipSynced": true,
  "syncConfig": {
    "threadCount": 3,
    "batchSize": 5000
  }
}
```

**æ‰§è¡Œç»“æœ**ï¼š
```
ä»»åŠ¡å†…å»é‡:
- index-user-2024 (keyword: "user")
- index-common (keyword: "user") â† ä¿ç•™ç¬¬ä¸€ä¸ªå…³é”®å­—
- index-data-2024 (keyword: "data")

è·¨ä»»åŠ¡å»é‡:
- æ£€æŸ¥ synced_indices è¡¨
- å‡è®¾ index-user-2024 å·²åŒæ­¥ï¼Œè·³è¿‡
- æœ€ç»ˆåŒæ­¥: index-common, index-data-2024
```

### ç¤ºä¾‹ 2: ç¦ç”¨è·¨ä»»åŠ¡å»é‡ï¼ˆå¼ºåˆ¶é‡æ–°åŒæ­¥ï¼‰

```json
{
  "units": ["index-user-2024"],
  "skipSynced": false,
  "syncConfig": {
    "threadCount": 1,
    "batchSize": 5000
  }
}
```

**æ‰§è¡Œç»“æœ**ï¼š
```
- ä¸æ£€æŸ¥ synced_indices è¡¨
- å¼ºåˆ¶é‡æ–°åŒæ­¥ index-user-2024
- æ›´æ–° synced_indices è¡¨çš„ sync_count
```

---

## ğŸ¯ ä½¿ç”¨åœºæ™¯

### åœºæ™¯ 1: å¤šå…³é”®å­—æœç´¢

```
ç”¨æˆ·æ“ä½œ:
1. è¾“å…¥å…³é”®å­—: "user", "common", "data"
2. å‰ç«¯æŸ¥è¯¢ ESï¼Œè·å–æ¯ä¸ªå…³é”®å­—çš„ç´¢å¼•åˆ—è¡¨
3. æäº¤ä»»åŠ¡é…ç½®

åç«¯å¤„ç†:
1. ä»»åŠ¡å†…å»é‡: æ¯ä¸ªç´¢å¼•åªä¿ç•™ä¸€æ¬¡
2. è·¨ä»»åŠ¡å»é‡: è·³è¿‡å·²åŒæ­¥çš„ç´¢å¼•
3. åˆ›å»ºä»»åŠ¡å•å…ƒï¼Œè®°å½•å…³é”®å­—æ ‡ç­¾
4. æ‰§è¡ŒåŒæ­¥
5. å®Œæˆåè®°å½•åˆ° synced_indices
```

### åœºæ™¯ 2: å®šæœŸåŒæ­¥

```
åœºæ™¯: æ¯å¤©åŒæ­¥æ–°å¢çš„ç´¢å¼•

ç¬¬ä¸€å¤©:
- å…³é”®å­—: "log-2024"
- åŒ¹é…: log-2024-01-01, log-2024-01-02
- åŒæ­¥å®Œæˆï¼Œè®°å½•åˆ° synced_indices

ç¬¬äºŒå¤©:
- å…³é”®å­—: "log-2024"
- åŒ¹é…: log-2024-01-01, log-2024-01-02, log-2024-01-03
- è·¨ä»»åŠ¡å»é‡: è·³è¿‡å‰ä¸¤ä¸ª
- åªåŒæ­¥: log-2024-01-03
```

### åœºæ™¯ 3: å¼ºåˆ¶é‡æ–°åŒæ­¥

```
åœºæ™¯: æ•°æ®æœ‰é—®é¢˜ï¼Œéœ€è¦é‡æ–°åŒæ­¥

æ“ä½œ:
- è®¾ç½® skipSynced = false
- æäº¤ä»»åŠ¡

ç»“æœ:
- ä¸æ£€æŸ¥ synced_indices
- å¼ºåˆ¶é‡æ–°åŒæ­¥æ‰€æœ‰ç´¢å¼•
- æ›´æ–° synced_indices çš„åŒæ­¥æ¬¡æ•°
```

---

## ğŸ” ç®¡ç†åŠŸèƒ½

### æŸ¥è¯¢å·²åŒæ­¥ç´¢å¼•

```rust
/// è·å–å·²åŒæ­¥çš„ç´¢å¼•åˆ—è¡¨
pub async fn list_synced_indices(
    &self,
    source_id: &str,
) -> Result<Vec<SyncedIndex>> {
    self.storage.list_synced_indices(source_id).await
}

/// å·²åŒæ­¥ç´¢å¼•
#[derive(Debug, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct SyncedIndex {
    pub index_name: String,
    pub first_synced_at: DateTime<Utc>,
    pub last_synced_at: DateTime<Utc>,
    pub sync_count: i32,
    pub last_task_id: String,
}
```

### æ¸…é™¤åŒæ­¥å†å²

```rust
/// æ¸…é™¤æŒ‡å®šç´¢å¼•çš„åŒæ­¥å†å²
pub async fn clear_synced_index(
    &self,
    source_id: &str,
    index_name: &str,
) -> Result<()> {
    self.storage.clear_synced_index(source_id, index_name).await
}

/// æ¸…é™¤æ‰€æœ‰åŒæ­¥å†å²
pub async fn clear_all_synced_indices(
    &self,
    source_id: &str,
) -> Result<()> {
    self.storage.clear_all_synced_indices(source_id).await
}
```

---

## ğŸ“ å‰ç«¯é›†æˆ

### ä»»åŠ¡åˆ›å»ºæµç¨‹

```typescript
// 1. ç”¨æˆ·è¾“å…¥å…³é”®å­—
const keywords = ['user', 'common', 'data'];

// 2. æŸ¥è¯¢æ¯ä¸ªå…³é”®å­—åŒ¹é…çš„ç´¢å¼•
const keywordMappings = [];
for (const keyword of keywords) {
  const indices = await searchIndices(sourceId, keyword);
  keywordMappings.push({
    keyword,
    indices
  });
}

// 3. æå–æ‰€æœ‰ç´¢å¼•ï¼ˆå‰ç«¯ä¹Ÿå¯ä»¥åšä¸€æ¬¡å»é‡å±•ç¤ºï¼‰
const allIndices = new Set();
for (const mapping of keywordMappings) {
  mapping.indices.forEach(index => allIndices.add(index));
}

// 4. åˆ›å»ºä»»åŠ¡é…ç½®
const taskConfig = {
  units: Array.from(allIndices),
  keywords: keywordMappings,
  skipSynced: true,  // é»˜è®¤è·³è¿‡å·²åŒæ­¥
  syncConfig: {
    threadCount: 4,
    batchSize: 5000
  }
};

// 5. æäº¤ä»»åŠ¡
await createTask({
  id: uuid(),
  name: 'å¤šå…³é”®å­—åŒæ­¥ä»»åŠ¡',
  sourceId,
  targetId,
  config: JSON.stringify(taskConfig)
});
```

---

## ğŸ“š ç›¸å…³æ–‡æ¡£

- [ä»»åŠ¡è°ƒåº¦ä¸æ–­ç‚¹ç»­ä¼ ](./ä»»åŠ¡è°ƒåº¦ä¸æ–­ç‚¹ç»­ä¼ .md) - ä»»åŠ¡è°ƒåº¦æœºåˆ¶
- [åŒæ­¥å¼•æ“å®ç°](../implementation/åŒæ­¥å¼•æ“å®ç°.md) - åŒæ­¥å¼•æ“è¯¦è§£
- [æ•°æ®åº“è®¾è®¡](../architecture/æ•°æ®åº“è®¾è®¡.md) - æ•°æ®åº“è¡¨ç»“æ„

---

**æ–‡æ¡£ç»´æŠ¤**: DataTrac å¼€å‘å›¢é˜Ÿ  
**æœ€åæ›´æ–°**: 2026-01-30
